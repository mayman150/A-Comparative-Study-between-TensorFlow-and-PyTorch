function_name,param_list,return_type
MultiLabelMarginLoss,"[{'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.Tensor.abs_,[],Tensor
torch.nn.functional.hardsigmoid,"[{'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.nn.functional.hardtanh_,[],Tensor
torch.Tensor.movedim,[],Tensor
torch.Tensor.sum,[],Tensor
torch.diagflat,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'offset', 'param_type': ['int'], 'is_optional': True}]",Tensor
torch.fft.fftfreq,"[{'param_name': 'n', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'd', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
PoissonNLLLoss,"[{'param_name': 'log_input', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'full', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.allclose,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'atol', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'rtol', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'equal_nan', 'param_type': ['bool'], 'is_optional': True}]",bool
InstanceNorm3d,"[{'param_name': 'num_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
SELU,"[{'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': True}]",None
torch.nn.functional.sigmoid,[],Tensor
Dropout1d,"[{'param_name': 'p', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': True}]",None
torch.linalg.matrix_norm,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'ord', 'param_type': ['int', 'inf', 'inf', 'fro', 'nuc'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple', 'int]'], 'is_optional': True}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.tanh,[],Tensor
BatchNorm2d,"[{'param_name': 'num_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.sgn,[],Tensor
torch.cuda.max_memory_reserved,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",int
CustomFromMask,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': False}]",Tensor
torch.Tensor.greater_,[],Tensor
torch.Tensor.size,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}]",t
torch.cuda.get_rng_state_all,[],List
NAdam,"[{'param_name': 'params', 'param_type': ['iterable'], 'is_optional': False}, {'param_name': 'lr', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'betas', 'param_type': ['Tuple', 'float]'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'weight_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'momentum_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'decoupled_weight_decay', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'foreach', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'capturable', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'differentiable', 'param_type': ['bool'], 'is_optional': True}]",t
torch.hstack,"[{'param_name': 'tensors', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.cuda.memory_allocated,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",int
torch.square,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.gather,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'sparse_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.cuda.caching_allocator_alloc,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'stream', 'param_type': ['t'], 'is_optional': True}]",None
LazyConvTranspose2d,"[{'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'output_padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}]",None
torch.Tensor.arctan2,[],Tensor
torch.Tensor.divide,[],Tensor
torch.tanh,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.isnan,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.erf_,[],Tensor
torch.histogram,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'bins', 'param_type': ['bin'], 'is_optional': False}, {'param_name': 'range', 'param_type': ['tupleoffloat'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'density', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.squeeze,[],Tensor
torch.fmod,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
ModuleList,"[{'param_name': 'modules', 'param_type': ['iterable'], 'is_optional': True}]",ModuleList
torch.Tensor.atanh_,[],Tensor
torch.nn.functional.pdist,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'p', 'param_type': [''], 'is_optional': False}]",Tensor
torch.isneginf,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.isposinf,[],Tensor
torch.nn.utils.rnn.pack_sequence,"[{'param_name': 'sequences', 'param_type': ['list'], 'is_optional': False}, {'param_name': 'enforce_sorted', 'param_type': ['bool'], 'is_optional': True}]",PackedSequence
torch.autograd.graph.Node.name,[],str
torch.Tensor.cos,[],Tensor
torch.nn.functional.upsample_nearest,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['intorTuple', 'int]orTuple', 'int', 'int]'], 'is_optional': False}, {'param_name': 'scale_factor', 'param_type': ['int'], 'is_optional': False}]",None
torch.autograd.graph.Node.register_hook,[],RemovableHandle
torch.sparse.softmax,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.linalg.householder_product,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'tau', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.nanmean,[],Tensor
GRU,"[{'param_name': 'input_size', 'param_type': ['input_siz'], 'is_optional': False}, {'param_name': 'hidden_size', 'param_type': ['hidden_siz'], 'is_optional': False}, {'param_name': 'num_layers', 'param_type': ['num_layer'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['batch_firs'], 'is_optional': False}, {'param_name': 'dropout', 'param_type': ['dropou'], 'is_optional': False}, {'param_name': 'bidirectional', 'param_type': ['bidirectiona'], 'is_optional': False}]",None
torch.erfinv,[],Tensor
torch.matmul,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.functional.scaled_dot_product_attention,"[{'param_name': 'query', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'key', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'value', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'attn_mask', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dropout_p', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'is_causal', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'scale', 'param_type': ['optionalpythonfloat'], 'is_optional': False}]",Tensor
torch.compiler.assume_constant_result,"[{'param_name': 'fn', 'param_type': ['f'], 'is_optional': False}]",None
torch._foreach_log10,[],List
RandomStructured,"[{'param_name': 'amount', 'param_type': ['int', 'float'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}]",Tensor
ConvTranspose1d,"[{'param_name': 'Note', 'param_type': ['NoteCurrentlyonlytheQNNPACKengineisimplementedPlease', 'setthet'], 'is_optional': False}]",None
torch.Tensor.histc,[],Tensor
torch.nn.modules.module.register_module_full_backward_pre_hook,[],t
LazyConv3d,"[{'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding_mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}]",None
torch.deg2rad,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
ConvertCustomConfig,[],ConvertCustomConfig
torch.xlogy,[],Tensor
torch.nn.functional.softplus,[],Tensor
torch.nn.functional.max_pool3d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['kernel_siz'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['ceil_mod'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['return_indice'], 'is_optional': False}]",None
torch.nn.functional.conv_transpose1d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['weigh'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'output_padding', 'param_type': ['output_paddin'], 'is_optional': False}, {'param_name': 'groups', 'param_type': ['group'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}]",Tensor
torch.nn.utils.prune.global_unstructured,"[{'param_name': 'pruning_method', 'param_type': ['pruning_metho'], 'is_optional': False}]",None
torch.optim.Optimizer.load_state_dict,"[{'param_name': 'state_dict', 'param_type': ['dict'], 'is_optional': False}]",None
LSTMCell,"[{'param_name': 'input_size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'hidden_size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': False}]",None
MarginRankingLoss,"[{'param_name': 'margin', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.jit.wait,[],T
torch.Tensor.bfloat16,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.greater,[],Tensor
RNNCell,"[{'param_name': 'input_size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'hidden_size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'nonlinearity', 'param_type': ['str'], 'is_optional': False}]",None
torch.clone,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
HingeEmbeddingLoss,"[{'param_name': 'margin', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.nn.functional.softsign,[],Tensor
torch.linalg.solve_ex,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'left', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_errors', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.arctanh,[],Tensor
torch.unique,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'sorted', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'return_inverse', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'return_counts', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}]",Tensor
RandomUnstructured,"[{'param_name': 'name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'amount', 'param_type': ['int', 'float'], 'is_optional': False}]",Tensor
torch.Tensor.round,[],Tensor
torch.nn.functional.multilabel_margin_loss,[],Tensor
LayerNorm,"[{'param_name': 'normalized_shape', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'elementwise_affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': False}]",None
torch.cov,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'correction', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'fweights', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'aweights', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.sigmoid,[],Tensor
torch.fmin,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.new_full,"[{'param_name': 'fill_value', 'param_type': ['scalar'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'pin_memory', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.sym_int,"[{'param_name': 'a', 'param_type': ['SymInt', 'SymFloat', 'object'], 'is_optional': False}]",None
torch.hann_window,"[{'param_name': 'window_length', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'periodic', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch._foreach_erfc,[],List
torch.expm1,[],Tensor
torch.fft.rfftn,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardnon'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.negative,[],Tensor
torch.Tensor.triu_,[],Tensor
torch.nn.utils.parameters_to_vector,"[{'param_name': '', 'param_type': [''], 'is_optional': False}]",Tensor
torch.index_select,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['Tensor', 'Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.functional.relu_,[],Tensor
torch.linalg.diagonal,[],Tensor
torch.Tensor.bitwise_right_shift_,[],Tensor
torch.hsplit,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'indices_or_sections', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.nn.functional.embedding_bag,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'offsets', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'max_norm', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'norm_type', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'scale_grad_by_freq', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'sparse', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'per_sample_weights', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'include_last_offset', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'padding_idx', 'param_type': ['int'], 'is_optional': True}]",Tensor
torch.utils.generate_methods_for_privateuse1_backend,"[{'param_name': 'for_tensor', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'for_module', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'for_storage', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'unsupported_dtype', 'param_type': ['List'], 'is_optional': False}]",None
torch.broadcast_shapes,"[{'param_name': 'shapes', 'param_type': ['t'], 'is_optional': False}]",shapet
torch.Tensor.masked_select,[],Tensor
torch.Tensor.igammac_,[],Tensor
torch.fft.fftshift,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int', 'Tuple'], 'is_optional': True}]",Tensor
torch.Tensor.minimum,[],Tensor
torch.Tensor.exp,[],Tensor
torch.fake_quantize_per_channel_affine,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'scale', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'axis', 'param_type': ['int32'], 'is_optional': False}, {'param_name': 'quant_min', 'param_type': ['int64'], 'is_optional': False}, {'param_name': 'quant_max', 'param_type': ['int64'], 'is_optional': False}]",Tensor
torch.Tensor.exp_,[],Tensor
Unflatten,"[{'param_name': 'dim', 'param_type': ['Union', 'str]'], 'is_optional': False}, {'param_name': 'unflattened_size', 'param_type': ['Union', 'Tuple', 'List', 'NamedShape]'], 'is_optional': False}]",None
torch.Tensor.all,[],Tensor
torch.Tensor.log10,[],Tensor
torch.Tensor.not_equal,[],Tensor
torch.triu_indices,"[{'param_name': 'row', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'col', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'offset', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.row_stack,[],Tensor
torch.Tensor.acosh_,[],Tensor
torch.jit.script,"[{'param_name': 'obj', 'param_type': ['Callable', 'class', 'nnModule'], 'is_optional': False}, {'param_name': 'example_inputs', 'param_type': ['Union', 'Dict', 'List', 'None]'], 'is_optional': False}]",None
torch.cumprod,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.bitwise_not_,[],Tensor
torch.orgqr,[],Tensor
torch.linalg.cholesky_ex,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'upper', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_errors', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.cuda.get_device_name,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",str
torch.Tensor.diagonal_scatter,[],Tensor
LeakyReLU,"[{'param_name': 'scale', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'negative_slope', 'param_type': ['float'], 'is_optional': False}]",None
AdaptiveMaxPool2d,"[{'param_name': 'output_size', 'param_type': ['Union', 'None', 'Tuple', 'Optional'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['bool'], 'is_optional': False}]",None
torch.nn.functional.hinge_embedding_loss,[],Tensor
torch._foreach_cosh,[],List
torch.jit.fork,"[{'param_name': 'func', 'param_type': ['callable', 't'], 'is_optional': False}, {'param_name': 'args', 'param_type': ['arg'], 'is_optional': False}, {'param_name': 'kwargs', 'param_type': ['kwarg'], 'is_optional': False}]",torchjitFuture
torch.Tensor.cuda,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': False}, {'param_name': 'non_blocking', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.nn.functional.gumbel_softmax,"[{'param_name': 'logits', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'tau', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'hard', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.searchsorted,"[{'param_name': 'sorted_sequence', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'values', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'out_int32', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'right', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'side', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'sorter', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.functional.softmin,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
LPPool2d,"[{'param_name': 'kernel_size', 'param_type': ['Union', 'Tuple', 'int]]'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['Union', 'Tuple', 'int]]'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['bool'], 'is_optional': False}]",None
LazyConv1d,"[{'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding_mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}]",None
torch.fft.rfftfreq,"[{'param_name': 'n', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'd', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.autograd.profiler.profile.key_averages,"[{'param_name': 'group_by_input_shapes', 'param_type': ['group_by_input_shape'], 'is_optional': False}, {'param_name': 'group_by_stack_n', 'param_type': ['group_by_stack_'], 'is_optional': False}]",None
torch.nn.functional.max_unpool2d,[],Tensor
torch.logaddexp2,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.blackman_window,"[{'param_name': 'window_length', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'periodic', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.conj_physical_,[],Tensor
torch.Tensor.masked_fill,[],Tensor
torch.cuda.set_device,"[{'param_name': 'device', 'param_type': ['t', 'int'], 'is_optional': False}]",None
torch.lgamma,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.expm1,[],Tensor
torch.Tensor.hsplit,[],Tensor
torch.func.functional_call,"[{'param_name': 'Note', 'param_type': ['NoteIfthemodulehasactiveparametrizations', 'passingavalueintheparameter_and_buffer_dictsargumentwiththenamesettotheregularparameternamewillcompletelydisabletheparametrizationIfyouwanttoapplytheparametrizationfunctiontothevaluepassedpleasesetthekeyassubmodule_nameparametrizationsparameter_name'], 'is_optional': False}, {'param_name': 'tie_weights', 'param_type': ['bool'], 'is_optional': True}]",Any
torch.mps.manual_seed,"[{'param_name': 'seed', 'param_type': ['int'], 'is_optional': False}]",None
torch.mps.set_per_process_memory_fraction,"[{'param_name': 'fraction', 'param_type': ['float'], 'is_optional': False}]",None
torch.rsqrt,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
elu,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'scale', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'alpha', 'param_type': ['float'], 'is_optional': False}]",Tensor
torch.randperm,"[{'param_name': 'n', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'generator', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'pin_memory', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.outer,[],Tensor
torch.get_deterministic_debug_mode,[],int
torch.Tensor.t,[],Tensor
torch.Tensor.transpose,[],Tensor
torch.Tensor.resolve_conj,[],Tensor
torch.Tensor.put_,"[{'param_name': 'index', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'source', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'accumulate', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.cuda.manual_seed,"[{'param_name': 'seed', 'param_type': ['int'], 'is_optional': False}]",None
torch.Tensor.addmv_,[],Tensor
LazyInstanceNorm1d,"[{'param_name': 'num_features', 'param_type': ['num_feature'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
MultiheadAttention,"[{'param_name': 'query', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'key', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'value', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'key_padding_mask', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'need_weights', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'attn_mask', 'param_type': ['Optional'], 'is_optional': False}]",Tuple
torch.Tensor.pow_,[],Tensor
torch.is_floating_point,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.roll,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'shifts', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dims', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.Tensor.tril,[],Tensor
torch.hypot,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.flatten,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'start_dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'end_dim', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.nn.functional.grid_sample,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'grid', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mode', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'padding_mode', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'align_corners', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.bitwise_not,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
hardswish,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'scale', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.Tensor.ge,[],Tensor
torch.cuda.make_graphed_callables,"[{'param_name': 'callables', 'param_type': ['t', 'tupleofthese'], 'is_optional': False}, {'param_name': 'sample_args', 'param_type': ['Tensor', 'Tensor'], 'is_optional': False}, {'param_name': 'num_warmup_iters', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'allow_unused_input', 'param_type': ['bool'], 'is_optional': False}]",None
torch.cholesky_solve,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'input2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'upper', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.new_empty,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'pin_memory', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.fmod_,[],Tensor
torch.float_power,"[{'param_name': 'input', 'param_type': ['Tensor', 'Number'], 'is_optional': False}, {'param_name': 'exponent', 'param_type': ['Tensor', 'Number'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
ConvTranspose3d,"[{'param_name': 'in_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'output_padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}]",None
torch.linalg.lu,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'pivot', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.subtract,[],Tensor
BCELoss,"[{'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.inner,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.einsum,"[{'param_name': 'equation', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'operands', 'param_type': ['List'], 'is_optional': False}]",Tensor
torch.bitwise_right_shift,"[{'param_name': 'input', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.addbmm_,[],Tensor
torch.sparse.sum,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.nn.functional.dropout1d,"[{'param_name': 'p', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'training', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.sym_not,"[{'param_name': 'a', 'param_type': ['SymBool', 'bool'], 'is_optional': False}]",None
torch.Tensor.take,[],Tensor
torch.cuda.set_rng_state_all,"[{'param_name': 'new_states', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.tensor_split,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'indices_or_sections', 'param_type': ['Tensor', 'int'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}]",Tensor
torch.autograd.gradcheck,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'inputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'atol', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'rtol', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'raise_exception', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_sparse_nnz', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'nondet_tol', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'check_undefined_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_batched_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_batched_forward_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_forward_ad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_backward_ad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'fast_mode', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'masked', 'param_type': ['bool'], 'is_optional': True}]",bool
conv1d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['weigh'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}, {'param_name': 'groups', 'param_type': ['group'], 'is_optional': False}, {'param_name': 'padding_mode', 'param_type': ['padding_mod'], 'is_optional': False}, {'param_name': 'scale', 'param_type': ['scal'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['zero_poin'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['dtyp'], 'is_optional': False}]",None
torch.fft.fft2,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardnon'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.seed,[],int
torch.Tensor.log1p,[],Tensor
torch.nn.functional.binary_cross_entropy_with_logits,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'target', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'pos_weight', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.modules.module.register_module_parameter_registration_hook,[],t
torch.Tensor.adjoint,[],Tensor
torch.Tensor.gather,[],Tensor
torch.scatter_add,[],Tensor
torch._foreach_frac,[],List
torch.Tensor.sign,[],Tensor
torch.nn.functional.selu,[],Tensor
torch.nn.functional.multi_margin_loss,[],Tensor
torch.Tensor.sum_to_size,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.nn.functional.kl_div,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'target', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'log_target', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.std_mean,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'correction', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",None
torch.corrcoef,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.rsqrt,[],Tensor
torch.Tensor.remainder_,[],Tensor
torch.mode,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.requires_grad_,"[{'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': False}]",Tensor
Hardshrink,"[{'param_name': 'lambd', 'param_type': ['float'], 'is_optional': False}]",None
MaxUnpool2d,"[{'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.Tensor.cumsum,[],Tensor
torch.Tensor.gt,[],Tensor
torch.quantize_per_channel,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'scales', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'zero_points', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'axis', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': False}]",Tensor
PruningContainer,"[{'param_name': 'method', 'param_type': ['subclassofBasePruningMethod'], 'is_optional': False}]",Tensor
Stream,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'priority', 'param_type': ['int'], 'is_optional': True}]",None
torch.Tensor.maximum,[],Tensor
torch.cuda.nvtx.mark,"[{'param_name': 'msg', 'param_type': ['str'], 'is_optional': False}]",None
CosineEmbeddingLoss,"[{'param_name': 'margin', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.Tensor.det,[],Tensor
torch.nn.modules.module.register_module_backward_hook,[],t
torch.kthvalue,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'k', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.numpy,"[{'param_name': 'force', 'param_type': ['bool'], 'is_optional': False}]",numpyndarray
torch.vmap,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'in_dims', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out_dims', 'param_type': ['int', 'Tuple'], 'is_optional': False}, {'param_name': 'randomness', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'chunk_size', 'param_type': ['None', 'int'], 'is_optional': False}]",Callable
torch.Tensor.corrcoef,[],Tensor
torch.Tensor.index_copy_,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'tensor', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.where,[],Tensor
torch._foreach_sinh,[],List
RNN,"[{'param_name': 'input_size', 'param_type': ['input_siz'], 'is_optional': False}, {'param_name': 'hidden_size', 'param_type': ['hidden_siz'], 'is_optional': False}, {'param_name': 'num_layers', 'param_type': ['num_layer'], 'is_optional': False}, {'param_name': 'nonlinearity', 'param_type': ['nonlinearit'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['batch_firs'], 'is_optional': False}, {'param_name': 'dropout', 'param_type': ['dropou'], 'is_optional': False}, {'param_name': 'bidirectional', 'param_type': ['bidirectiona'], 'is_optional': False}]",None
torch.Tensor.chalf,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.index_reduce_,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'source', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'reduce', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'include_self', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.linalg.svd,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'full_matrices', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'driver', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.cpu.current_stream,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",Stream
PolynomialLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'total_iters', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'power', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.bitwise_and,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['othe'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.index_reduce,[],Tensor
torch.linalg.det,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.lcm_,[],Tensor
torch.Tensor.arcsinh_,[],Tensor
torch.nn.functional.dropout2d,"[{'param_name': 'p', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'training', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.Tensor.copysign_,[],Tensor
torch.Tensor.repeat_interleave,[],Tensor
torch.full_like,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'fill_value', 'param_type': ['fill_valu'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.zeros_like,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.triangular_solve,"[{'param_name': 'b', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'upper', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'transpose', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'unitriangular', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor', 'Tensor'], 'is_optional': False}]",None
torch.abs,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.index_put,[],Tensor
torch.imag,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.bitwise_left_shift_,[],Tensor
torch.Tensor.type,"[{'param_name': 'dtype', 'param_type': ['dtype', 'string'], 'is_optional': False}, {'param_name': 'non_blocking', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'kwargs', 'param_type': ['kwarg'], 'is_optional': False}]",Tensor
torch.Tensor.true_divide_,[],Tensor
torch.atleast_2d,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.isinf,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.exponential_,[],Tensor
CTCLoss,"[{'param_name': 'blank', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'zero_infinity', 'param_type': ['bool'], 'is_optional': True}]",None
torch.nextafter,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.chunk,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'chunks', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",Tensor
Softplus,"[{'param_name': 'beta', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'threshold', 'param_type': ['int'], 'is_optional': False}]",None
torch.signal.windows.exponential,"[{'param_name': 'M', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'center', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'tau', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'sym', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.is_signed,[],bool
torch.Tensor.logit_,[],Tensor
torch.Tensor.neg,[],Tensor
torch.nn.functional.adaptive_avg_pool2d,"[{'param_name': 'output_size', 'param_type': ['None'], 'is_optional': False}]",Tensor
torch.Tensor.argmax,[],Tensor
torch.nn.functional.cross_entropy,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'target', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'ignore_index', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'label_smoothing', 'param_type': ['float'], 'is_optional': True}]",Tensor
torch.Tensor.subtract_,[],Tensor
torch.Tensor.diagflat,[],Tensor
Sigmoid,"[{'param_name': 'scale', 'param_type': ['scal'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['zero_poin'], 'is_optional': False}]",None
BCEWithLogitsLoss,"[{'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'pos_weight', 'param_type': ['Tensor'], 'is_optional': True}]",None
torch.smm,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.index_put_,"[{'param_name': 'indices', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'values', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'accumulate', 'param_type': ['bool'], 'is_optional': False}]",Tensor
Threshold,"[{'param_name': 'threshold', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'value', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",None
convert_fx,"[{'param_name': 'graph_module', 'param_type': [''], 'is_optional': False}, {'param_name': 'convert_custom_config', 'param_type': [''], 'is_optional': False}, {'param_name': '_remove_qconfig', 'param_type': [''], 'is_optional': False}, {'param_name': 'qconfig_mapping', 'param_type': [''], 'is_optional': False}, {'param_name': 'backend_config', 'param_type': ['BackendConfig'], 'is_optional': False}]",GraphModule
torch.Tensor.greater_equal_,[],Tensor
torch.le,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.q_scale,[],float
torch.linalg.slogdet,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.is_contiguous,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",bool
torch.argmax,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.byte,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.linalg.vector_norm,"[{'param_name': 'x', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'ord', 'param_type': ['int', 'float', 'inf', 'inf', 'fro', 'nuc'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int', 'Tuple'], 'is_optional': True}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.index_copy,[],Tensor
Identity,"[{'param_name': 'args', 'param_type': ['Any'], 'is_optional': False}, {'param_name': 'kwargs', 'param_type': ['Any'], 'is_optional': False}]",None
torch.gcd,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
CUDAGraph,"[{'param_name': 'pool', 'param_type': ['optional'], 'is_optional': False}, {'param_name': 'capture_error_mode', 'param_type': ['str'], 'is_optional': True}]",None
torch.amin,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.hspmm,"[{'param_name': 'mat1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.sub,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'Number'], 'is_optional': False}, {'param_name': 'alpha', 'param_type': ['Number'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
AdaptiveLogSoftmaxWithLoss,"[{'param_name': 'in_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'n_classes', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'cutoffs', 'param_type': ['Sequence'], 'is_optional': False}, {'param_name': 'div_value', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'head_bias', 'param_type': ['bool'], 'is_optional': True}]",NamedTuplewithoutputandlossfields
torch.real,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.acosh,[],Tensor
torch.Tensor.divide_,[],Tensor
swap_module,"[{'param_name': 'mod', 'param_type': ['mo'], 'is_optional': False}, {'param_name': 'mapping', 'param_type': ['mappin'], 'is_optional': False}]",None
torch.Tensor.masked_fill_,"[{'param_name': 'mask', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'value', 'param_type': ['float'], 'is_optional': False}]",None
torch.nn.functional.feature_alpha_dropout,"[{'param_name': 'p', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'training', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.nn.functional.relu,[],Tensor
torch.sparse.addmm,"[{'param_name': 'mat', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'beta', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'alpha', 'param_type': ['Number'], 'is_optional': True}]",Tensor
torch.manual_seed,"[{'param_name': 'seed', 'param_type': ['int'], 'is_optional': False}]",Generat
torch.Tensor.element_size,[],int
torch.outer,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'vec2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
threshold,[],Tensor
RecordingObserver,"[{'param_name': 'dtype', 'param_type': ['dtyp'], 'is_optional': False}, {'param_name': 'qscheme', 'param_type': ['qschem'], 'is_optional': False}, {'param_name': 'reduce_range', 'param_type': ['reduce_rang'], 'is_optional': False}]",None
torch.polar,"[{'param_name': 'abs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'angle', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
linear,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'scale', 'param_type': ['double'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['pythonlong'], 'is_optional': False}]",Tensor
torch.sparse.sampled_addmm,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'beta', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'alpha', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.true_divide,[],Tensor
Softshrink,"[{'param_name': 'lambd', 'param_type': ['float'], 'is_optional': False}]",None
torch.linalg.lu_factor,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'pivot', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.nn.functional.log_softmax,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.linalg.lu_factor_ex,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'pivot', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_errors', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.bitwise_xor_,[],Tensor
torch.nn.utils.skip_init,"[{'param_name': '', 'param_type': ['Themodulemustacceptadevicearginitsconstruct'], 'is_optional': False}]",None
torch.Tensor.matrix_exp,[],Tensor
torch.mean,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.fft.ihfft2,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardn'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.angle,[],Tensor
torch.narrow,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'start', 'param_type': ['int', 'Tensor'], 'is_optional': False}, {'param_name': 'length', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.Tensor.absolute_,[],Tensor
torch.Tensor.ne,[],Tensor
Fold,"[{'param_name': 'output_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'stride', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.Tensor.arccos,[],Tensor
MinMaxObserver,"[{'param_name': 'This', 'param_type': ['Tensor', 'andusesthisstatistictocomputethequantizationparameters'], 'is_optional': False}]",None
AdaptiveMaxPool1d,"[{'param_name': 'output_size', 'param_type': ['Union', 'Tuple'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.char,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.cumprod,[],Tensor
torch.Tensor.unsqueeze,[],Tensor
torch.Tensor.tan,[],Tensor
PairwiseDistance,"[{'param_name': 'p', 'param_type': ['real'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': True}]",None
CosineAnnealingWarmRestarts,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'T_0', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'T_mult', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'eta_min', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.to,[],Tensor
ReLU6,"[{'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",None
Conv2d,"[{'param_name': 'mod', 'param_type': ['Module'], 'is_optional': False}]",None
ConvTranspose2d,"[{'param_name': 'For', 'param_type': ['F', 'please', 'seeConv2'], 'is_optional': False}]",None
torch.cholesky,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'upper', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.sym_float,"[{'param_name': 'a', 'param_type': ['SymInt', 'SymFloat', 'object'], 'is_optional': False}]",None
torch.cartesian_prod,"[{'param_name': 'tensors', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.nonzero,[],Tensor
torch.randint,"[{'param_name': 'low', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'high', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['tuple'], 'is_optional': False}, {'param_name': 'generator', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.bitwise_and_,[],Tensor
torch.Tensor.baddbmm,[],Tensor
torch.Tensor.argsort,[],Tensor
torch.Tensor.ravel,[],Tensor
Flatten,"[{'param_name': 'start_dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'end_dim', 'param_type': ['int'], 'is_optional': False}]",None
torch.meshgrid,"[{'param_name': 'tensors', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'indexing', 'param_type': ['Optional'], 'is_optional': False}]",Tensor
torch.arccos,[],Tensor
torch.slice_scatter,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'src', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'start', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'end', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'step', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.quantile,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'q', 'param_type': ['float', 'Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'interpolation', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.expm1_,[],Tensor
torch.Tensor.unfold,"[{'param_name': 'dimension', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'step', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.cuda.change_current_allocator,"[{'param_name': 'allocator', 'param_type': ['t'], 'is_optional': False}]",None
LazyConv2d,"[{'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding_mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}]",None
torch.fft.ifftshift,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int', 'Tuple'], 'is_optional': True}]",Tensor
torch.acos,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.linalg.svdvals,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'driver', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.addcdiv,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'tensor1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'tensor2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'value', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.cuda.device_count,[],int
FeatureAlphaDropout,"[{'param_name': 'p', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': True}]",None
torch.Tensor.sgn_,[],Tensor
torch.Tensor.atan_,[],Tensor
torch.Tensor.diff,[],Tensor
torch.Tensor.softmax,[],Tensor
torch.squeeze,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}]",Tensor
conv3d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['weigh'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}, {'param_name': 'groups', 'param_type': ['group'], 'is_optional': False}, {'param_name': 'padding_mode', 'param_type': ['padding_mod'], 'is_optional': False}, {'param_name': 'scale', 'param_type': ['scal'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['zero_poin'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['dtyp'], 'is_optional': False}]",None
ReplicationPad3d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.normal,"[{'param_name': 'mean', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'std', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'generator', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.tensor,"[{'param_name': 'data', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'pin_memory', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.true_divide,[],Tensor
torch.linalg.tensorinv,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'ind', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.functional.affine_grid,"[{'param_name': 'theta', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['t'], 'is_optional': False}, {'param_name': 'align_corners', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.sparse.mm,"[{'param_name': 'mat1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'reduce', 'param_type': ['str'], 'is_optional': True}]",None
torch.logical_or,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.kron,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.absolute,[],Tensor
torch.Tensor.diag,[],Tensor
torch.any,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.functional.fractional_max_pool3d,"[{'param_name': 'kernel_size', 'param_type': ['kernel_siz'], 'is_optional': False}, {'param_name': 'output_size', 'param_type': ['output_siz'], 'is_optional': False}, {'param_name': 'output_ratio', 'param_type': ['output_rati'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['return_indice'], 'is_optional': False}]",None
torch.concat,[],Tensor
graph,"[{'param_name': 'cuda_graph', 'param_type': ['t'], 'is_optional': False}, {'param_name': 'pool', 'param_type': ['optional'], 'is_optional': False}, {'param_name': 'stream', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'capture_error_mode', 'param_type': ['str'], 'is_optional': True}]",None
torch.inverse,[],Tensor
torch.fft.fftn,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardnon'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.sin_,[],Tensor
torch.cuda.reset_max_memory_cached,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",None
torch.nn.functional.adaptive_max_pool2d,"[{'param_name': 'output_size', 'param_type': ['output_siz'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['return_indice'], 'is_optional': False}]",None
MultiStepLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'milestones', 'param_type': ['list'], 'is_optional': False}, {'param_name': 'gamma', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.cuda.is_available,[],bool
torch.Tensor.logcumsumexp,[],Tensor
torch.Tensor.sinc,[],Tensor
torch.Tensor.vdot,[],Tensor
torch.Tensor.swapaxes,[],Tensor
torch.addmm,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'beta', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'alpha', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
ModuleDict,"[{'param_name': 'modules', 'param_type': ['iterable'], 'is_optional': True}]",Iterable
torch.rand_like,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.promote_types,"[{'param_name': 'type1', 'param_type': ['t'], 'is_optional': False}, {'param_name': 'type2', 'param_type': ['t'], 'is_optional': False}]",dtype
torch.Tensor.logical_xor_,[],Tensor
torch.Tensor.arctanh_,[],Tensor
Attribute,"[{'param_name': 'value', 'param_type': ['valu'], 'is_optional': False}, {'param_name': 'type', 'param_type': ['typ'], 'is_optional': False}]",None
torch.Tensor.arcsinh,[],Tensor
torch.Tensor.subtract,[],Tensor
torch.randn,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'generator', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'pin_memory', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch._foreach_atan,[],List
torch.Tensor.normal_,[],Tensor
torch.Tensor.asinh_,[],Tensor
torch._foreach_reciprocal,[],List
torch.Tensor.cauchy_,[],Tensor
torch.Tensor.nelement,[],int
torch.jit.trace,"[{'param_name': 'Tracing', 'param_type': ['possiblydynamic'], 'is_optional': False}, {'param_name': 'In', 'param_type': ['InthereturnedScriptModule', 'operationsthathavedifferentbehavi', 'nomatterwhichmodetheScriptModuleisin'], 'is_optional': False}, {'param_name': 'example_inputs', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'check_trace', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_inputs', 'param_type': ['listoftuples'], 'is_optional': True}, {'param_name': 'check_tolerance', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'strict', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'example_kwarg_inputs', 'param_type': ['dict'], 'is_optional': True}]",None
MultiMarginLoss,"[{'param_name': 'p', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'margin', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.sinh,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.repeat,"[{'param_name': 'sizes', 'param_type': ['t', 'int'], 'is_optional': False}]",Tensor
FuseCustomConfig,[],FuseCustomConfig
torch.signal.windows.general_cosine,"[{'param_name': 'M', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'a', 'param_type': ['Iterable'], 'is_optional': False}, {'param_name': 'sym', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.linalg.eig,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.gcd,[],Tensor
UpsamplingBilinear2d,"[{'param_name': 'size', 'param_type': ['intorTuple', 'int]'], 'is_optional': True}, {'param_name': 'scale_factor', 'param_type': ['floatorTuple', 'float]'], 'is_optional': True}]",None
TransformerEncoderLayer,"[{'param_name': 'd_model', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'nhead', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dim_feedforward', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dropout', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'activation', 'param_type': ['Union', 'Callable', 'Tensor'], 'is_optional': False}, {'param_name': 'layer_norm_eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'norm_first', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.log2,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
BatchNorm1d,"[{'param_name': 'num_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
torch.addr,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'vec1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'vec2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'beta', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'alpha', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
Dropout,"[{'param_name': 'p', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",None
torch.cuda.nvtx.range_push,"[{'param_name': 'msg', 'param_type': ['str'], 'is_optional': False}]",None
torch.Tensor.cdouble,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.digamma,[],Tensor
torch.Tensor.abs,[],Tensor
LazyInstanceNorm3d,"[{'param_name': 'num_features', 'param_type': ['num_feature'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
torch.nn.utils.rnn.pad_packed_sequence,"[{'param_name': 'sequence', 'param_type': ['PackedSequence'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'padding_value', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'total_length', 'param_type': ['int'], 'is_optional': True}]",Tuple
torch.as_strided,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['tuple', 'ints'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['tuple', 'ints'], 'is_optional': False}, {'param_name': 'storage_offset', 'param_type': ['int'], 'is_optional': True}]",Tensor
ConvTranspose3d,"[{'param_name': 'Note', 'param_type': ['NoteCurrentlyonlytheFBGEMMengineisimplementedPlease', 'setthet'], 'is_optional': False}]",None
CosineAnnealingLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'T_max', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'eta_min', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.clamp,[],Tensor
torch.mps.set_rng_state,"[{'param_name': 'new_state', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.Tensor.take_along_dim,[],Tensor
torch.cummax,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
FakeQuantize,"[{'param_name': 'observer', 'param_type': ['module'], 'is_optional': False}, {'param_name': 'observer_kwargs', 'param_type': ['optional'], 'is_optional': False}]",None
torch.Tensor.lcm,[],Tensor
torch.nn.utils.spectral_norm,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'n_power_iterations', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}]",T_module
torch.Tensor.dense_dim,[],int
torch.flipud,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.i0_,[],Tensor
torch.Tensor.cosh,[],Tensor
torch.nn.utils.parametrize.is_parametrized,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'tensor_name', 'param_type': ['str'], 'is_optional': True}]",bool
torch.nn.functional.pairwise_distance,[],Tensor
torch.greater_equal,[],Tensor
torch.Tensor.arccos_,[],Tensor
torch.nn.functional.avg_pool3d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['kernel_siz'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['ceil_mod'], 'is_optional': False}, {'param_name': 'count_include_pad', 'param_type': ['count_include_pa'], 'is_optional': False}, {'param_name': 'divisor_override', 'param_type': ['divis'], 'is_optional': False}]",Tensor
torch.Tensor.arctan,[],Tensor
LazyModuleMixin,"[{'param_name': 'Modules', 'param_type': ['s'], 'is_optional': False}]",None
torch.nansum,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
ExponentialLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'gamma', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.igamma_,[],Tensor
MaxUnpool3d,"[{'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.Tensor.q_per_channel_scales,[],Tensor
torch.Tensor.bitwise_left_shift,[],Tensor
torch.fft.rfft,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'n', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardnon'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
SequentialLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'schedulers', 'param_type': ['list'], 'is_optional': False}, {'param_name': 'milestones', 'param_type': ['list'], 'is_optional': False}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.nn.functional.hardshrink,[],Tensor
torch.take,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
fuse_modules,"[{'param_name': 'model', 'param_type': ['mode'], 'is_optional': False}, {'param_name': 'modules_to_fuse', 'param_type': ['modules_to_fus'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['inplac'], 'is_optional': False}, {'param_name': 'fuser_func', 'param_type': ['fuser_fun'], 'is_optional': False}, {'param_name': 'fuse_custom_config_dict', 'param_type': ['fuse_custom_config_dic'], 'is_optional': False}]",None
torch.softmax,[],Tensor
torch.Tensor.eq,[],Tensor
torch.det,[],Tensor
torch.nn.functional.glu,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.Tensor.is_floating_point,[],bool
torch.Tensor.q_zero_point,[],int
torch.nn.functional.elu_,[],Tensor
torch.Tensor.logical_and,[],Tensor
SmoothL1Loss,"[{'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'beta', 'param_type': ['float'], 'is_optional': True}]",None
ReLU6,"[{'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",None
torch.nn.functional.softmax,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.nn.utils.prune.ln_structured,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'amount', 'param_type': ['int', 'float'], 'is_optional': False}, {'param_name': 'n', 'param_type': ['int', 'float', 'inf', 'inf', 'fro', 'nuc'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'importance_scores', 'param_type': ['Tensor'], 'is_optional': False}]",modulennModule
torch._foreach_asin,[],List
torch.Tensor.addcdiv_,[],Tensor
torch.nn.utils.stateless.functional_call,"[{'param_name': 'args', 'param_type': ['arg'], 'is_optional': False}, {'param_name': 'tie_weights', 'param_type': ['bool'], 'is_optional': True}]",Any
torch.unflatten,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'sizes', 'param_type': ['Tuple'], 'is_optional': False}]",Tensor
torch.complex,"[{'param_name': 'real', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'imag', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.to_dense,"[{'param_name': 'dtype', 'param_type': ['dtype'], 'is_optional': False}, {'param_name': 'masked_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
GaussianNLLLoss,"[{'param_name': 'full', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.Tensor.arcsin_,[],Tensor
torch._foreach_abs,[],List
torch.nn.functional.unfold,[],Tensor
celu,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'alpha', 'param_type': ['float'], 'is_optional': False}]",Tensor
TripletMarginLoss,"[{'param_name': 'margin', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'p', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'swap', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.Tensor.int_repr,[],Tensor
torch.Tensor.lerp,[],Tensor
torch.Tensor.stride,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}]",tuple
torch.tril_indices,"[{'param_name': 'row', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'col', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'offset', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}]",Tensor
LnStructured,"[{'param_name': 'amount', 'param_type': ['int', 'float'], 'is_optional': False}, {'param_name': 'n', 'param_type': ['int', 'float', 'inf', 'inf', 'fro', 'nuc'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}]",Tensor
torch.Tensor.backward,"[{'param_name': 'gradient', 'param_type': ['Tensor', 'None'], 'is_optional': False}, {'param_name': 'retain_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'create_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'inputs', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.signal.windows.nuttall,"[{'param_name': 'M', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'sym', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.pow,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'exponent', 'param_type': ['float', 'Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.reciprocal,[],Tensor
inference_mode,"[{'param_name': 'mode', 'param_type': ['bool', 'function'], 'is_optional': False}]",None
torch.nn.utils.prune.custom_from_mask,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'mask', 'param_type': ['Tensor'], 'is_optional': False}]",modulennModule
torch.nn.functional.torch.nn.parallel.data_parallel,"[{'param_name': 'module', 'param_type': ['Module'], 'is_optional': False}, {'param_name': 'inputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'device_ids', 'param_type': ['listofint'], 'is_optional': False}, {'param_name': 'output_device', 'param_type': ['listofint'], 'is_optional': False}]",Tensor
CELU,"[{'param_name': 'alpha', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",None
torch.polygamma,[],Tensor
torch.Tensor.asinh,[],Tensor
torch.cuda.get_gencode_flags,[],str
torch.cuda.power_draw,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",int
torch.Tensor.cos_,[],Tensor
torch.Tensor.sigmoid_,[],Tensor
torch._foreach_tan,[],List
torch.Tensor.argwhere,[],Tensor
torch.linalg.matrix_power,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'n', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.logsumexp,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",None
torch.nanmedian,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor', 'Tensor'], 'is_optional': False}]",Tensor
get_default_qat_qconfig_mapping,"[{'param_name': 'backend', 'param_type': [''], 'is_optional': False}, {'param_name': 'version', 'param_type': [''], 'is_optional': False}]",QConfigMapping
quantize,"[{'param_name': 'model', 'param_type': ['mode'], 'is_optional': False}, {'param_name': 'run_fn', 'param_type': ['run_f'], 'is_optional': False}, {'param_name': 'run_args', 'param_type': ['run_arg'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['inplac'], 'is_optional': False}, {'param_name': 'mapping', 'param_type': ['mappin'], 'is_optional': False}]",None
clamp,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'min', 'param_type': ['mi'], 'is_optional': False}, {'param_name': 'max', 'param_type': ['ma'], 'is_optional': False}]",Tensor
torch.nn.functional.leaky_relu,[],Tensor
torch.Tensor.addr,[],Tensor
UninitializedParameter,"[{'param_name': 'Unlike', 'param_type': ['Unlikeat', 'uninitializedparametersholdnodataandattemptingtoaccesssomeproperties', 'liketheirshape', 'willthrowaruntimeerr', 'movingittoadifferentdeviceandconvertingittoaregulart'], 'is_optional': False}]",None
torch.cuda.memory_stats,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",Dict
torch.Tensor.cumsum_,[],Tensor
torch.nn.utils.parametrizations.spectral_norm,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'n_power_iterations', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}]",Module
torch.quantized_batch_norm,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mean', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'var', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'output_scale', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'output_zero_point', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.sparse_csc_tensor,"[{'param_name': 'ccol_indices', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'row_indices', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'values', 'param_type': ['array_list'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['list', 'tuple', 't'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_invariants', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.fmin,[],Tensor
torch.Tensor.less_equal_,[],Tensor
torch.Tensor.index_add_,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'source', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'alpha', 'param_type': ['Number'], 'is_optional': False}]",Tensor
torch.Tensor.lgamma,[],Tensor
ZeroPad3d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.Tensor.add_,[],Tensor
torch.unbind,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",seq
torch._foreach_lgamma,[],List
HistogramObserver,"[{'param_name': 'bins', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'upsample_rate', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['dtype'], 'is_optional': False}, {'param_name': 'qscheme', 'param_type': ['qschem'], 'is_optional': False}, {'param_name': 'reduce_range', 'param_type': ['reduce_rang'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['Tensor'], 'is_optional': False}]",None
Adagrad,"[{'param_name': 'params', 'param_type': ['iterable'], 'is_optional': False}, {'param_name': 'lr', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'lr_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'weight_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'foreach', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'maximize', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'differentiable', 'param_type': ['bool'], 'is_optional': True}]",t
torch.Tensor.nan_to_num_,[],Tensor
torch.is_storage,"[{'param_name': 'obj', 'param_type': ['Object'], 'is_optional': False}]",None
torch.optim.Optimizer.step,"[{'param_name': 'closure', 'param_type': ['Callable'], 'is_optional': False}]",None
prepare_qat,"[{'param_name': 'model', 'param_type': ['mode'], 'is_optional': False}, {'param_name': 'mapping', 'param_type': ['mappin'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['inplac'], 'is_optional': False}]",None
torch.bitwise_left_shift,"[{'param_name': 'input', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.atanh,[],Tensor
AdamW,"[{'param_name': 'params', 'param_type': ['iterable'], 'is_optional': False}, {'param_name': 'lr', 'param_type': ['float', 'Tensor'], 'is_optional': True}, {'param_name': 'betas', 'param_type': ['Tuple', 'float]'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'weight_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'amsgrad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'maximize', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'foreach', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'capturable', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'differentiable', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'fused', 'param_type': ['bool'], 'is_optional': True}]",t
torch.nn.utils.prune.random_structured,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'amount', 'param_type': ['int', 'float'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",modulennModule
torch.Tensor.log2_,[],Tensor
torch._foreach_ceil,[],List
torch.Tensor.as_strided,[],Tensor
torch.set_deterministic_debug_mode,"[{'param_name': 'debug_mode', 'param_type': ['str', 'int'], 'is_optional': False}]",None
torch.Tensor.clone,[],Tensor
torch.mul,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.mean,[],Tensor
torch.cuda.comm.broadcast_coalesced,"[{'param_name': 'tensors', 'param_type': ['sequence'], 'is_optional': False}, {'param_name': 'devices', 'param_type': ['Iterable', 'str'], 'is_optional': False}, {'param_name': 'buffer_size', 'param_type': ['int'], 'is_optional': False}]",None
torch.logical_not,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.mm,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.autograd.grad,"[{'param_name': 'outputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'inputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'grad_outputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'retain_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'create_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'allow_unused', 'param_type': ['Optional'], 'is_optional': True}, {'param_name': 'is_grads_batched', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'materialize_grads', 'param_type': ['bool'], 'is_optional': True}]",Tuple
torch.linalg.multi_dot,"[{'param_name': 'tensors', 'param_type': ['Sequence'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",None
torch.multinomial,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'num_samples', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'replacement', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'generator', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.rad2deg,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
convert,"[{'param_name': 'module', 'param_type': ['modul'], 'is_optional': False}, {'param_name': 'mapping', 'param_type': ['mappin'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['inplac'], 'is_optional': False}, {'param_name': 'convert_custom_config_dict', 'param_type': ['convert_custom_config_dic'], 'is_optional': False}]",None
torch.nn.functional.max_pool1d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['kernel_siz'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['ceil_mod'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['return_indice'], 'is_optional': False}]",None
torch.set_warn_always,"[{'param_name': 'b', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.unflatten,[],Tensor
torch.ldexp,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.scatter_reduce,[],Tensor
Embedding,"[{'param_name': 'num_embeddings', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'embedding_dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'padding_idx', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'max_norm', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'norm_type', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'scale_grad_by_freq', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'sparse', 'param_type': ['bool'], 'is_optional': True}]",None
MultiplicativeLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'lr_lambda', 'param_type': ['function', 'list'], 'is_optional': False}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.addbmm,"[{'param_name': 'batch1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'batch2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'beta', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'alpha', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.mps.profiler.profile,"[{'param_name': 'mode', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'wait_until_completed', 'param_type': ['bool'], 'is_optional': False}]",None
torch.hamming_window,"[{'param_name': 'window_length', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'periodic', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'alpha', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'beta', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
device_of,"[{'param_name': 'obj', 'param_type': ['Tensor', 'St'], 'is_optional': False}]",None
torch.autograd.graph.Node.register_prehook,[],RemovableHandle
torch.nn.functional.max_pool2d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['kernel_siz'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['ceil_mod'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['return_indice'], 'is_optional': False}]",None
torch.Tensor.is_conj,[],bool
torch.stft,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'n_fft', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'hop_length', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'win_length', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'window', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'center', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'pad_mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'normalized', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'onesided', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'return_complex', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.transpose_,[],Tensor
torch.trunc,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.cpu,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.arctan2,[],Tensor
torch.func.linearize,"[{'param_name': 'func', 'param_type': ['Callable'], 'is_optional': False}, {'param_name': 'primals', 'param_type': ['Tensor'], 'is_optional': False}]",Tuple
torch.bmm,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
PlaceholderObserver,"[{'param_name': 'dtype', 'param_type': ['dtyp'], 'is_optional': False}, {'param_name': 'quant_min', 'param_type': ['quant_mi'], 'is_optional': False}, {'param_name': 'quant_max', 'param_type': ['quant_ma'], 'is_optional': False}, {'param_name': 'custom_op_name', 'param_type': ['custom_op_nam'], 'is_optional': False}, {'param_name': 'compute_dtype', 'param_type': ['deprecated'], 'is_optional': False}, {'param_name': 'is_dynamic', 'param_type': ['is_dynami'], 'is_optional': False}]",None
torch.linalg.cond,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'p', 'param_type': ['int', 'inf', 'inf', 'fro', 'nuc'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.trunc_,[],Tensor
torch.Tensor.eq_,[],Tensor
torch.Tensor.ndimension,[],int
torch.svd,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'some', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'compute_uv', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.view,"[{'param_name': 'shape', 'param_type': ['t', 'int'], 'is_optional': False}]",Tensor
torch.diagonal,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'offset', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim1', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim2', 'param_type': ['int'], 'is_optional': True}]",Tensor
TransformerEncoder,"[{'param_name': 'encoder_layer', 'param_type': ['encoder_laye'], 'is_optional': False}, {'param_name': 'num_layers', 'param_type': ['num_layer'], 'is_optional': False}, {'param_name': 'norm', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'enable_nested_tensor', 'param_type': ['enable_nested_tenso'], 'is_optional': False}]",Tensor
torch.nn.functional.adaptive_avg_pool3d,"[{'param_name': 'output_size', 'param_type': ['None'], 'is_optional': False}]",Tensor
torch.nn.functional.one_hot,"[{'param_name': 'tensor', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'num_classes', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.autograd.backward,"[{'param_name': 'tensors', 'param_type': ['Sequence', 'Tensor'], 'is_optional': False}, {'param_name': 'grad_tensors', 'param_type': ['Sequence'], 'is_optional': True}, {'param_name': 'retain_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'create_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'inputs', 'param_type': ['Sequence'], 'is_optional': True}]",None
torch.is_deterministic_algorithms_warn_only_enabled,[],bool
LocalResponseNorm,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'alpha', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'beta', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'k', 'param_type': ['float'], 'is_optional': False}]",None
torch.signal.windows.gaussian,"[{'param_name': 'M', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'std', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'sym', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.fft.ifft,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'n', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardn'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
Softmax,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",None
torch.minimum,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.hypot_,[],Tensor
torch.load,"[{'param_name': 'f', 'param_type': ['Union', 'PathLike', 'BinaryIO', 'IO'], 'is_optional': False}, {'param_name': 'map_location', 'param_type': ['Optional', 'str]', 'Tensor', 'device', 'str', 'Dict', 'str]]]'], 'is_optional': False}, {'param_name': 'pickle_module', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'weights_only', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'mmap', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'pickle_load_args', 'param_type': ['Any'], 'is_optional': False}]",Any
torch.Tensor.trunc,[],Tensor
torch.Tensor.to_sparse_csr,"[{'param_name': 'dense_dim', 'param_type': ['int'], 'is_optional': True}]",Tensor
torch.conj,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.cpu.stream,[],AbstractContextManager
torch.nn.functional.linear,[],Tensor
torch.autograd.graph.Node.metadata,[],dict
Bilinear,"[{'param_name': 'in1_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'in2_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': False}]",None
torch.cuda.stream,"[{'param_name': 'stream', 'param_type': ['Stream'], 'is_optional': False}]",StreamContext
torch.nn.utils.parametrizations.orthogonal,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'orthogonal_map', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'use_trivialization', 'param_type': ['bool'], 'is_optional': True}]",Module
torch.scatter,[],Tensor
UpsamplingNearest2d,"[{'param_name': 'size', 'param_type': ['intorTuple', 'int]'], 'is_optional': True}, {'param_name': 'scale_factor', 'param_type': ['floatorTuple', 'float]'], 'is_optional': True}]",None
torch.nn.modules.module.register_module_buffer_registration_hook,[],t
torch.compile,"[{'param_name': 'model', 'param_type': ['Callable'], 'is_optional': False}, {'param_name': 'fullgraph', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'dynamic', 'param_type': ['bool', 'None'], 'is_optional': False}, {'param_name': 'backend', 'param_type': ['str', 'Callable'], 'is_optional': False}, {'param_name': 'inductor', 'param_type': ['induct', 'whichisagoodbalancebetweenperf'], 'is_optional': False}, {'param_name': 'Non', 'param_type': [''], 'is_optional': False}, {'param_name': 'Experimental', 'param_type': ['None'], 'is_optional': False}, {'param_name': 'To', 'param_type': ['Toregisteranoutoftreecustombackendhttpspyt'], 'is_optional': False}, {'param_name': 'mode', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'default', 'param_type': ['defaultisthedefaultmode', 'whichisagoodbalancebetweenperf'], 'is_optional': False}, {'param_name': 'reduceoverhead', 'param_type': ['reduceoverheadisamodethatreducestheoverheadofpythonwithCUDAgraphs', 'usefulf', 'aswewillcachethew', 'weonlyreduceoverheadf'], 'is_optional': False}, {'param_name': 'maxautotune', 'param_type': ['maxautotuneisamodethatleveragesTritonbasedmatrixmultiplicationsandconvolutionsItenablesCUDAgraphsbydefault'], 'is_optional': False}, {'param_name': 'maxautotunenocudagraphs', 'param_type': ['maxautotunenocudagraphsisamodesimilartomaxautotunebutwithoutCUDAgraph'], 'is_optional': False}, {'param_name': 'To', 'param_type': [''], 'is_optional': False}, {'param_name': 'options', 'param_type': ['dict'], 'is_optional': False}, {'param_name': 'epilogue_fusion', 'param_type': ['epilogue_fusionwhichfusespointwiseopsintotemplatesRequiresmax_autotunetoalsobese'], 'is_optional': False}, {'param_name': 'max_autotune', 'param_type': ['max_autotunewhichwillprofiletopickthebestmatmulconfiguratio'], 'is_optional': False}, {'param_name': 'fallback_random', 'param_type': ['fallback_randomwhichisusefulwhendebuggingaccuracyissue'], 'is_optional': False}, {'param_name': 'shape_padding', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'tritoncudagraphs', 'param_type': ['tritoncudagraphswhichwillreducetheoverheadofpythonwithCUDAgraph'], 'is_optional': False}, {'param_name': 'traceenabled', 'param_type': ['traceenabledwhichisthemostusefuldebuggingflagtoturno'], 'is_optional': False}, {'param_name': 'tracegraph_diagram', 'param_type': ['tracegraph_diagramwhichwillshowyouapictureofyourgraphafterfusio'], 'is_optional': False}, {'param_name': 'For', 'param_type': [''], 'is_optional': False}, {'param_name': 'disable', 'param_type': ['bool'], 'is_optional': False}]",Callable
torch.empty_strided,"[{'param_name': 'size', 'param_type': ['tupleofint'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['tupleofint'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'pin_memory', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.multinomial,[],Tensor
Hardsigmoid,"[{'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.pinverse,[],Tensor
torch.Tensor.tan_,[],Tensor
torch.rand,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'generator', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'pin_memory', 'param_type': ['bool'], 'is_optional': True}]",Tensor
SoftMarginLoss,"[{'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.atan,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.log,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.moveaxis,[],Tensor
torch.linalg.cholesky,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'upper', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.signbit,[],Tensor
torch.Tensor.logit,[],Tensor
Sequential,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}]",Sequential
torch.func.grad,"[{'param_name': 'func', 'param_type': ['Callable'], 'is_optional': False}, {'param_name': 'argnums', 'param_type': ['int', 'Tuple'], 'is_optional': False}, {'param_name': 'has_aux', 'param_type': ['bool'], 'is_optional': False}]",Callable
torch.Tensor.less_,[],Tensor
MSELoss,"[{'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.linalg.cross,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.addcdiv,[],Tensor
torch.Tensor.sub,[],Tensor
Upsample,"[{'param_name': 'size', 'param_type': ['intorTuple', 'int]orTuple', 'int', 'int]'], 'is_optional': True}, {'param_name': 'scale_factor', 'param_type': ['floatorTuple', 'float]orTuple', 'float', 'float]'], 'is_optional': True}, {'param_name': 'mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'align_corners', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'recompute_scale_factor', 'param_type': ['bool'], 'is_optional': True}]",None
NoopObserver,"[{'param_name': 'dtype', 'param_type': ['dtyp'], 'is_optional': False}, {'param_name': 'custom_op_name', 'param_type': ['custom_op_nam'], 'is_optional': False}]",None
ELU,"[{'param_name': 'alpha', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",None
HuberLoss,"[{'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'delta', 'param_type': ['float'], 'is_optional': True}]",None
torch.concatenate,[],Tensor
torch.Tensor.sign_,[],Tensor
torch.Tensor.masked_scatter_,"[{'param_name': 'mask', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'source', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.Tensor.arctan_,[],Tensor
torch.broadcast_to,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'shape', 'param_type': ['list', 'tuple', 't'], 'is_optional': False}]",Tensor
torch.autograd.profiler.profile.export_chrome_trace,"[{'param_name': 'path', 'param_type': ['str'], 'is_optional': False}]",None
torch._foreach_sigmoid,[],List
torch.Tensor.isclose,[],Tensor
OneCycleLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'max_lr', 'param_type': ['float', 'list'], 'is_optional': False}, {'param_name': 'total_steps', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'epochs', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'steps_per_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'pct_start', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'anneal_strategy', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'cycle_momentum', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'base_momentum', 'param_type': ['float', 'list'], 'is_optional': False}, {'param_name': 'max_momentum', 'param_type': ['float', 'list'], 'is_optional': False}, {'param_name': 'div_factor', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'final_div_factor', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'three_phase', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.nn.functional.adaptive_max_pool1d,"[{'param_name': 'output_size', 'param_type': ['output_siz'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['return_indice'], 'is_optional': False}]",None
torch.Tensor.isinf,[],Tensor
torch.linspace,"[{'param_name': 'start', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'end', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'steps', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
fuse_fx,"[{'param_name': 'model', 'param_type': [''], 'is_optional': False}, {'param_name': 'fuse_custom_config', 'param_type': [''], 'is_optional': False}]",GraphModule
torch.set_default_dtype,"[{'param_name': 'd', 'param_type': ['t'], 'is_optional': False}]",None
Softmin,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",None
torch.Tensor.rsqrt_,[],Tensor
torch.arange,"[{'param_name': 'start', 'param_type': ['Number'], 'is_optional': False}, {'param_name': 'end', 'param_type': ['Number'], 'is_optional': False}, {'param_name': 'step', 'param_type': ['Number'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.compiler.disable,"[{'param_name': 'fn', 'param_type': ['optional'], 'is_optional': False}, {'param_name': 'recursive', 'param_type': ['optional'], 'is_optional': False}]",None
torch.fft.fft,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'n', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardnon'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.functional.embedding,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'padding_idx', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'max_norm', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'norm_type', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'scale_grad_by_freq', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'sparse', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.log10_,[],Tensor
torch.Tensor.tanh_,[],Tensor
FractionalMaxPool3d,"[{'param_name': 'kernel_size', 'param_type': ['Union', 'Tuple', 'int', 'int]]'], 'is_optional': False}, {'param_name': 'output_size', 'param_type': ['Union', 'Tuple', 'int', 'int]]'], 'is_optional': False}, {'param_name': 'output_ratio', 'param_type': ['Union', 'Tuple', 'float', 'float]]'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['bool'], 'is_optional': False}]",None
torch.autograd.gradgradcheck,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'inputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'grad_outputs', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'atol', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'rtol', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'gen_non_contig_grad_outputs', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'raise_exception', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'nondet_tol', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'check_undefined_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_batched_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'fast_mode', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'masked', 'param_type': ['bool'], 'is_optional': True}]",bool
MovingAverageMinMaxObserver,"[{'param_name': 'This', 'param_type': ['Tensor', 'andusesthisstatistictocomputethequantizationparameters'], 'is_optional': False}]",None
torch.Tensor.index_add,[],Tensor
torch.nn.functional.binary_cross_entropy,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'target', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",Tensor
torch.Tensor.narrow_copy,[],Tensor
torch.Tensor.nextafter,[],Tensor
CrossEntropyLoss,"[{'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'ignore_index', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'label_smoothing', 'param_type': ['float'], 'is_optional': True}]",None
torch.nn.functional.pad,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'pad', 'param_type': ['tuple'], 'is_optional': False}, {'param_name': 'mode', 'param_type': ['mod'], 'is_optional': False}, {'param_name': 'value', 'param_type': ['valu'], 'is_optional': False}]",Tensor
torch.cuda.reset_max_memory_allocated,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",None
CyclicLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'base_lr', 'param_type': ['float', 'list'], 'is_optional': False}, {'param_name': 'max_lr', 'param_type': ['float', 'list'], 'is_optional': False}, {'param_name': 'step_size_up', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'step_size_down', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'mode', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'gamma', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'scale_fn', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'scale_mode', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'cycle_momentum', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'base_momentum', 'param_type': ['float', 'list'], 'is_optional': False}, {'param_name': 'max_momentum', 'param_type': ['float', 'list'], 'is_optional': False}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.allclose,[],Tensor
torch.Tensor.deg2rad,[],Tensor
RNNBase,"[{'param_name': '', 'param_type': [''], 'is_optional': False}]",None
torch.lu_solve,"[{'param_name': 'b', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'LU_data', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'LU_pivots', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.nanquantile,[],Tensor
torch.nn.functional.conv_transpose3d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['weigh'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'output_padding', 'param_type': ['output_paddin'], 'is_optional': False}, {'param_name': 'groups', 'param_type': ['group'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}]",Tensor
torch.Tensor.masked_scatter,[],Tensor
torch.exp,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.functional.gaussian_nll_loss,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'target', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'var', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'full', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",Tensor
torch.linalg.ldl_factor_ex,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'hermitian', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_errors', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.log2,[],Tensor
torch.nn.modules.module.register_module_forward_hook,"[{'param_name': 'hook', 'param_type': ['Callable'], 'is_optional': False}, {'param_name': 'always_call', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'hook', 'param_type': ['Callable'], 'is_optional': False}, {'param_name': 'always_call', 'param_type': ['bool'], 'is_optional': False}]",t
ELU,"[{'param_name': 'scale', 'param_type': ['scal'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['zero_poin'], 'is_optional': False}, {'param_name': 'alpha', 'param_type': ['float'], 'is_optional': False}]",None
torch.Tensor.indices,[],Tensor
torch.Tensor.baddbmm_,[],Tensor
torch.Tensor.matrix_power,[],Tensor
Linear,"[{'param_name': 'mod', 'param_type': ['Module'], 'is_optional': False}]",None
torch.Tensor.cosh_,[],Tensor
torch.Tensor.diag_embed,[],Tensor
torch.randint_like,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'low', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'high', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.tril_,[],Tensor
torch.Tensor.q_per_channel_axis,[],int
torch.signal.windows.blackman,"[{'param_name': 'M', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'sym', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
ReLU,"[{'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",None
torch.from_dlpack,"[{'param_name': 'ext_tensor', 'param_type': ['objectwith__dlpack__attribute', 'aDLPackcapsule'], 'is_optional': False}]",Tensor
torch.nn.functional.poisson_nll_loss,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'target', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'log_input', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'full', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",Tensor
torch.linalg.matmul,[],Tensor
torch.Tensor.renorm_,[],Tensor
torch.linalg.lu_solve,"[{'param_name': 'LU', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'pivots', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'B', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'left', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'adjoint', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.eq,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'float'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.cuda.jiterator._create_jit_fn,"[{'param_name': 'code_string', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'kwargs', 'param_type': ['Dict'], 'is_optional': True}]",Callable
AvgPool1d,"[{'param_name': 'kernel_size', 'param_type': ['Union', 'Tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['Union', 'Tuple'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['Union', 'Tuple'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'count_include_pad', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.square,[],Tensor
torch.nn.utils.prune.random_unstructured,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'amount', 'param_type': ['int', 'float'], 'is_optional': False}]",modulennModule
torch.diag_embed,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'offset', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim1', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim2', 'param_type': ['int'], 'is_optional': True}]",Tensor
AdaptiveMaxPool3d,"[{'param_name': 'output_size', 'param_type': ['Union', 'None', 'Tuple', 'Optional', 'Optional'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['bool'], 'is_optional': False}]",None
torch.jit.save,"[{'param_name': 'm', 'param_type': [''], 'is_optional': False}, {'param_name': 'f', 'param_type': [''], 'is_optional': False}, {'param_name': '_extra_files', 'param_type': ['_extra_file'], 'is_optional': False}]",None
torch.floor,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.fft.irfft,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'n', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardn'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.type_as,"[{'param_name': 'tensor', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.ne_,[],Tensor
AvgPool3d,"[{'param_name': 'kernel_size', 'param_type': ['Union', 'Tuple', 'int', 'int]]'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['Union', 'Tuple', 'int', 'int]]'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['Union', 'Tuple', 'int', 'int]]'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'count_include_pad', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'divisor_override', 'param_type': ['Optional'], 'is_optional': False}]",None
torch.frexp,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.ger,[],Tensor
torch.cuda.can_device_access_peer,[],bool
torch.Tensor.flatten,[],Tensor
QuantStub,"[{'param_name': 'qconfig', 'param_type': ['qconfi'], 'is_optional': False}]",None
torch.jit.optimize_for_inference,[],ScriptModule
torch.sparse_coo_tensor,"[{'param_name': 'indices', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'values', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['list', 'tuple', 't'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_invariants', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'is_coalesced', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.bitwise_xor,[],Tensor
ReflectionPad2d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
MultiLabelSoftMarginLoss,"[{'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.compiled_with_cxx11_abi,[],bool
torch.Tensor.not_equal_,[],Tensor
torch.mps.profiler.start,"[{'param_name': 'mode', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'wait_until_completed', 'param_type': ['bool'], 'is_optional': False}]",None
Conv2d,"[{'param_name': 'in_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': True}, {'param_name': 'padding_mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}]",None
torch.Tensor.crow_indices,[],Tensor
torch.Tensor.bernoulli,[],Tensor
torch.resolve_conj,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.pin_memory,[],Tensor
TransformerDecoder,"[{'param_name': 'decoder_layer', 'param_type': ['decoder_laye'], 'is_optional': False}, {'param_name': 'num_layers', 'param_type': ['num_layer'], 'is_optional': False}, {'param_name': 'norm', 'param_type': ['n'], 'is_optional': False}]",Tensor
torch.func.hessian,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'argnums', 'param_type': ['int', 'Tuple'], 'is_optional': False}]",None
ScriptModule,"[{'param_name': 'name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'module', 'param_type': ['Module'], 'is_optional': False}, {'param_name': 'hook', 'param_type': ['Callable'], 'is_optional': False}, {'param_name': 'prepend', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'with_kwargs', 'param_type': ['bool'], 'is_optional': False}]",Module
torch.Tensor.matmul,[],Tensor
torch.copysign,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'Number'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.cuda.temperature,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",int
torch.quantized_max_pool1d,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['listofint'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['listofint'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['listofint'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['listofint'], 'is_optional': True}, {'param_name': 'ceil_mode', 'param_type': ['bool'], 'is_optional': True}]",Tensor
ReduceLROnPlateau,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'mode', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'factor', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'patience', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'threshold', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'threshold_mode', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'cooldown', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'min_lr', 'param_type': ['float', 'list'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
Adam,"[{'param_name': 'params', 'param_type': ['iterable'], 'is_optional': False}, {'param_name': 'lr', 'param_type': ['float', 'Tensor'], 'is_optional': True}, {'param_name': 'betas', 'param_type': ['Tuple', 'float]'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'weight_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'amsgrad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'foreach', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'maximize', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'capturable', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'differentiable', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'fused', 'param_type': ['bool'], 'is_optional': True}]",t
torch.nn.functional.layer_norm,[],Tensor
torch.nn.functional.normalize,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'p', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.chain_matmul,"[{'param_name': 'matrices', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
ASGD,"[{'param_name': 'params', 'param_type': ['iterable'], 'is_optional': False}, {'param_name': 'lr', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'lambd', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'alpha', 'param_type': ['float'], 'is_optional': True}, {'param_name': 't0', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'weight_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'foreach', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'maximize', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'differentiable', 'param_type': ['bool'], 'is_optional': True}]",t
torch.Tensor.scatter_reduce,[],Tensor
torch.nn.functional.threshold,[],Tensor
TransformerDecoderLayer,"[{'param_name': 'd_model', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'nhead', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dim_feedforward', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dropout', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'activation', 'param_type': ['Union', 'Callable', 'Tensor'], 'is_optional': False}, {'param_name': 'layer_norm_eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'norm_first', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.Tensor.lu_solve,[],Tensor
torch.Tensor.equal,[],bool
torch.nn.functional.lp_pool1d,[],Tensor
torch.nn.functional.dropout3d,"[{'param_name': 'p', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'training', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.Tensor.isnan,[],Tensor
torch.Tensor.atan,[],Tensor
torch.fft.ifftn,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardn'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.addr_,[],Tensor
torch.atleast_1d,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.renorm,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'p', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'maxnorm', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.pow,[],Tensor
torch.nn.functional.conv2d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['weigh'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}, {'param_name': 'groups', 'param_type': ['group'], 'is_optional': False}]",Tensor
torch.Tensor.ge_,[],Tensor
CosineSimilarity,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}]",None
torch.conj_physical,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
LazyInstanceNorm2d,"[{'param_name': 'num_features', 'param_type': ['num_feature'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
torch.kaiser_window,"[{'param_name': 'window_length', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'periodic', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'beta', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.isfinite,[],Tensor
torch.trace,[],Tensor
torch.Tensor.logaddexp,[],Tensor
torch.Tensor.floor_,[],Tensor
torch.get_rng_state,[],Tensor
SGD,"[{'param_name': 'params', 'param_type': ['iterable'], 'is_optional': False}, {'param_name': 'lr', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'weight_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'dampening', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'nesterov', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'maximize', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'foreach', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'differentiable', 'param_type': ['bool'], 'is_optional': True}]",t
torch.Tensor.item,[],number
torch.nn.functional.triplet_margin_with_distance_loss,[],Tensor
torch.nn.functional.interpolate,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['intorTuple', 'int]orTuple', 'int', 'int]'], 'is_optional': False}, {'param_name': 'scale_factor', 'param_type': ['float', 'Tuple'], 'is_optional': False}, {'param_name': 'mode', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'align_corners', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'recompute_scale_factor', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'antialias', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.func.functionalize,"[{'param_name': 'func', 'param_type': ['Callable'], 'is_optional': False}, {'param_name': 'remove', 'param_type': ['str'], 'is_optional': False}]",Callable
AdaptiveAvgPool3d,"[{'param_name': 'output_size', 'param_type': ['Union', 'None', 'Tuple', 'Optional', 'Optional'], 'is_optional': False}]",None
torch.Tensor.quantile,[],Tensor
torch.Tensor.sspaddmm,[],Tensor
torch.cdist,"[{'param_name': 'x1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'x2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'p', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'compute_mode', 'param_type': ['str'], 'is_optional': False}]",Tensor
torch.Tensor.to_sparse_bsr,"[{'param_name': 'blocksize', 'param_type': ['list', 'tuple', 't'], 'is_optional': True}, {'param_name': 'dense_dim', 'param_type': ['int'], 'is_optional': True}]",Tensor
Linear,"[{'param_name': 'in_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': False}]",None
torch.poisson,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'generator', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.igammac,[],Tensor
torch.linalg.lstsq,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'B', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'rcond', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'driver', 'param_type': ['str'], 'is_optional': True}]",None
Hardswish,"[{'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",None
torch.jit.annotate,"[{'param_name': 'the_type', 'param_type': ['the_typ'], 'is_optional': False}, {'param_name': 'the_value', 'param_type': ['the_valu'], 'is_optional': False}]",None
torch.nn.functional.lp_pool2d,[],Tensor
torch.median,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor', 'Tensor'], 'is_optional': False}]",Tensor
JitScalarType,"[{'param_name': 'dtype', 'param_type': ['Optional'], 'is_optional': False}]",dtype
torch.Tensor.greater_equal,[],Tensor
torch.jit.trace_module,"[{'param_name': 'mod', 'param_type': ['t'], 'is_optional': False}, {'param_name': 'inputs', 'param_type': ['dict'], 'is_optional': False}, {'param_name': 'check_trace', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_inputs', 'param_type': ['listofdicts'], 'is_optional': True}, {'param_name': 'check_tolerance', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'example_inputs_is_kwarg', 'param_type': ['bool'], 'is_optional': True}]",None
Transformer,"[{'param_name': 'd_model', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'nhead', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'num_encoder_layers', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'num_decoder_layers', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dim_feedforward', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dropout', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'activation', 'param_type': ['Union', 'Callable', 'Tensor'], 'is_optional': False}, {'param_name': 'custom_encoder', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'custom_decoder', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'layer_norm_eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'norm_first', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.nn.functional.silu,[],Tensor
torch.combinations,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'r', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'with_replacement', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.nn.utils.rnn.pad_sequence,"[{'param_name': 'sequences', 'param_type': ['list'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'padding_value', 'param_type': ['float'], 'is_optional': True}]",Tensor
torch.Tensor.nextafter_,[],Tensor
Hardtanh,"[{'param_name': 'min_val', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'max_val', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'Input', 'param_type': [''], 'is_optional': False}, {'param_name': 'Output', 'param_type': [''], 'is_optional': False}]",None
torch._foreach_acos,[],List
ZeroPad1d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.unsqueeze,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.exp2,[],Tensor
torch.argsort,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'descending', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'stable', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.argmin,[],Tensor
ScriptFunction,"[{'param_name': 'get_debug_stateself', 'param_type': ['selft'], 'is_optional': False}]",t
LazyBatchNorm3d,"[{'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
torch.fliplr,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
StepLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'step_size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'gamma', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.signal.windows.hann,"[{'param_name': 'M', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'sym', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.nn.functional.hardtanh,[],Tensor
torch.nn.utils.parametrize.remove_parametrizations,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'tensor_name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'leave_parametrized', 'param_type': ['bool'], 'is_optional': True}]",Module
torch.jit.isinstance,"[{'param_name': 'obj', 'param_type': ['ob'], 'is_optional': False}, {'param_name': 'target_type', 'param_type': ['target_typ'], 'is_optional': False}]",bool
torch.Tensor.square_,[],Tensor
Dropout2d,"[{'param_name': 'p', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': True}]",None
torch.Tensor.vsplit,[],Tensor
torch.msort,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.conj_physical,[],Tensor
torch.Tensor.sparse_dim,[],int
torch.Tensor.index_fill_,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'value', 'param_type': ['float'], 'is_optional': False}]",Tensor
torch.Tensor.bitwise_or_,[],Tensor
torch.fft.ihfftn,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardn'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.fft.hfft,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'n', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardnon'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
MovingAveragePerChannelMinMaxObserver,"[{'param_name': 'This', 'param_type': ['Tensor', 'andusesthisstatistictocomputethequantizationparameters'], 'is_optional': False}]",None
torch.Tensor.gcd_,[],Tensor
torch.Tensor.geometric_,[],Tensor
torch.ones,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
BasePruningMethod,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'args', 'param_type': ['arg'], 'is_optional': False}, {'param_name': 'importance_scores', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'kwargs', 'param_type': ['kwarg'], 'is_optional': False}]",Tensor
torch.Tensor.triu,[],Tensor
torch.func.stack_module_state,[],Tuple
torch.Tensor.cholesky_solve,[],Tensor
torch.count_nonzero,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}]",Tensor
MaxPool2d,"[{'param_name': 'kernel_size', 'param_type': ['Union', 'Tuple', 'int]]'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['Union', 'Tuple', 'int]]'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['Union', 'Tuple', 'int]]'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['Union', 'Tuple', 'int]]'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['bool'], 'is_optional': False}]",None
BackendPatternConfig,"[{'param_name': 'There', 'param_type': ['Therearetwoobservationtypes'], 'is_optional': False}]",BackendPatternConfig
LazyBatchNorm2d,"[{'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.scatter_add,[],Tensor
Module,"[{'param_name': 'name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'module', 'param_type': ['Module'], 'is_optional': False}, {'param_name': 'hook', 'param_type': ['Callable'], 'is_optional': False}, {'param_name': 'prepend', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'with_kwargs', 'param_type': ['bool'], 'is_optional': False}]",Module
torch.Tensor.sigmoid,[],Tensor
torch.linalg.ldl_solve,"[{'param_name': 'LD', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'pivots', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'B', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'hermitian', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",Tensor
torch.use_deterministic_algorithms,"[{'param_name': 'mode', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'warn_only', 'param_type': ['bool'], 'is_optional': True}]",None
torch.Tensor.to_mkldnn,[],Tensor
torch.Tensor.dequantize,[],Tensor
torch.Tensor.fmod,[],Tensor
torch.Tensor.double,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
ReflectionPad3d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.Tensor.digamma_,[],Tensor
torch.Tensor.less_equal,[],Tensor
torch.Tensor.apply_,[],Tensor
ConstantPad1d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.autograd.functional.hvp,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'inputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'v', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'create_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'strict', 'param_type': ['bool'], 'is_optional': True}]",outputtuple
torch.Tensor.sinc_,[],Tensor
torch.compiler.list_backends,"[{'param_name': 'exclude_tags', 'param_type': ['optional'], 'is_optional': False}]",List
torch.argwhere,"[{'param_name': 'input', 'param_type': ['input'], 'is_optional': False}]",Tensor
torch.Tensor.addcmul_,[],Tensor
torch.Tensor.bitwise_and,[],Tensor
torch._foreach_log2,[],List
torch.nn.functional.alpha_dropout,[],Tensor
torch.bernoulli,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'generator', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.xlogy,[],Tensor
torch.nn.functional.huber_loss,[],Tensor
torch.linalg.pinv,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'rcond', 'param_type': ['float', 'Tensor'], 'is_optional': True}, {'param_name': 'atol', 'param_type': ['float', 'Tensor'], 'is_optional': True}, {'param_name': 'rtol', 'param_type': ['float', 'Tensor'], 'is_optional': True}, {'param_name': 'hermitian', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
BatchNorm3d,"[{'param_name': 'num_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
prepare,"[{'param_name': 'model', 'param_type': ['mode'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['inplac'], 'is_optional': False}, {'param_name': 'allow_list', 'param_type': ['allow_lis'], 'is_optional': False}, {'param_name': 'observer_non_leaf_module_list', 'param_type': ['observer_non_leaf_module_lis'], 'is_optional': False}, {'param_name': 'prepare_custom_config_dict', 'param_type': ['prepare_custom_config_dic'], 'is_optional': False}]",None
torch.Tensor.hypot,[],Tensor
torch.Tensor.mv,[],Tensor
torch.Tensor.amax,[],Tensor
torch.Tensor.reciprocal_,[],Tensor
torch.Tensor.bincount,[],Tensor
torch.cpu.synchronize,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",None
torch.clip,[],Tensor
torch.Tensor.resize_as_,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.lt,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'float'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.maximum,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.std,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'correction', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.cos,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.diff,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'n', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'prepend', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'append', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.atan2,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.addmv,[],Tensor
torch.amax,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.ormqr,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'tau', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'left', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'transpose', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
Unfold,"[{'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}]",None
torch.Tensor.new_ones,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'pin_memory', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.is_warn_always_enabled,[],bool
DeQuantStub,"[{'param_name': 'qconfig', 'param_type': ['qconfi'], 'is_optional': False}]",None
torch.nn.modules.module.register_module_module_registration_hook,[],t
torch.cuda.list_gpu_processes,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",str
torch.sin,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.functional.pixel_unshuffle,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'downscale_factor', 'param_type': ['int'], 'is_optional': False}]",Tensor
Adamax,"[{'param_name': 'params', 'param_type': ['iterable'], 'is_optional': False}, {'param_name': 'lr', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'betas', 'param_type': ['Tuple', 'float]'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'weight_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'foreach', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'maximize', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'differentiable', 'param_type': ['bool'], 'is_optional': True}]",t
torch.Tensor.is_complex,[],bool
torch.cosh,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.reshape,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'shape', 'param_type': ['tupleofint'], 'is_optional': False}]",Tensor
torch.Tensor.reshape,"[{'param_name': 'shape', 'param_type': ['tupleofints'], 'is_optional': False}]",Tensor
LBFGS,[],t
torch.cuda.synchronize,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",None
torch.nn.functional.hardswish,[],Tensor
torch.cuda.reset_peak_memory_stats,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",None
torch.nn.utils.remove_weight_norm,"[{'param_name': 'module', 'param_type': ['Module'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': True}]",T_module
LSTM,"[{'param_name': 'input_size', 'param_type': ['input_siz'], 'is_optional': False}, {'param_name': 'hidden_size', 'param_type': ['hidden_siz'], 'is_optional': False}, {'param_name': 'num_layers', 'param_type': ['num_layer'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['batch_firs'], 'is_optional': False}, {'param_name': 'dropout', 'param_type': ['dropou'], 'is_optional': False}, {'param_name': 'bidirectional', 'param_type': ['bidirectiona'], 'is_optional': False}, {'param_name': 'proj_size', 'param_type': ['proj_siz'], 'is_optional': False}]",None
torch.Tensor.xlogy_,[],Tensor
torch.nn.utils.weight_norm,"[{'param_name': 'module', 'param_type': ['Module'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}]",T_module
torch.Tensor.addcmul,[],Tensor
torch.nn.functional.softshrink,[],Tensor
torch.logcumsumexp,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.gt,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'float'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
LazyConvTranspose3d,"[{'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'output_padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}]",None
torch.Tensor.div,[],Tensor
torch.Tensor.scatter,[],Tensor
ZeroPad2d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.Tensor.addmm,[],Tensor
add_quant_dequant,"[{'param_name': 'module', 'param_type': ['modul'], 'is_optional': False}, {'param_name': 'quantize', 'param_type': ['thatwewantto'], 'is_optional': False}]",None
torch.Tensor.index_copy,[],Tensor
torch.nn.functional.pixel_shuffle,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'upscale_factor', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.nn.functional.multilabel_soft_margin_loss,[],Tensor
torch.nn.functional.avg_pool2d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['kernel_siz'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['ceil_mod'], 'is_optional': False}, {'param_name': 'count_include_pad', 'param_type': ['count_include_pa'], 'is_optional': False}, {'param_name': 'divisor_override', 'param_type': ['divis'], 'is_optional': False}]",Tensor
torch.Tensor.storage_offset,[],int
torch.Tensor.igamma,[],Tensor
torch.nn.utils.prune.remove,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': False}]",None
torch.Tensor.diagonal,[],Tensor
torch.rot90,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'k', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dims', 'param_type': ['alist'], 'is_optional': False}]",Tensor
torch.ne,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'float'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.atan2,[],Tensor
torch.quantized_max_pool2d,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['listofint'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['listofint'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['listofint'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['listofint'], 'is_optional': True}, {'param_name': 'ceil_mode', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.linalg.ldl_factor,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'hermitian', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.autograd.functional.jacobian,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'inputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'create_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'strict', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'vectorize', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'strategy', 'param_type': ['str'], 'is_optional': True}]",Tensor
torch.nn.functional.cosine_embedding_loss,[],Tensor
torch.Tensor.mul_,[],Tensor
torch.cuda.get_arch_list,[],List
GRUCell,"[{'param_name': 'input_size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'hidden_size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': False}]",None
get_default_qconfig_mapping,"[{'param_name': 'backend', 'param_type': [''], 'is_optional': False}, {'param_name': 'version', 'param_type': [''], 'is_optional': False}]",QConfigMapping
torch.Tensor.conj,[],Tensor
torch.signal.windows.general_hamming,"[{'param_name': 'M', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'alpha', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'sym', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
ChannelShuffle,"[{'param_name': 'groups', 'param_type': ['int'], 'is_optional': False}]",None
torch.Tensor.positive,[],Tensor
torch.Tensor.renorm,[],Tensor
torch.swapdims,[],Tensor
torch.autograd.functional.hessian,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'inputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'create_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'strict', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'vectorize', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'outer_jacobian_strategy', 'param_type': ['str'], 'is_optional': True}]",Tensor
PerChannelMinMaxObserver,"[{'param_name': 'This', 'param_type': ['Tensor', 'andusesthisstatistictocomputethequantizationparameters'], 'is_optional': False}]",None
torch.equal,[],bool
torch.nn.functional.cosine_similarity,"[{'param_name': 'x1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'x2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}]",Tensor
torch.optim.Optimizer.add_param_group,"[{'param_name': 'param_group', 'param_type': ['dict'], 'is_optional': False}]",None
torch.Tensor.sqrt,[],Tensor
torch.ravel,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.func.replace_all_batch_norm_modules_,[],Module
torch.Tensor.tile,[],Tensor
torch.set_printoptions,"[{'param_name': 'precision', 'param_type': ['precisio'], 'is_optional': False}, {'param_name': 'threshold', 'param_type': ['threshol'], 'is_optional': False}, {'param_name': 'edgeitems', 'param_type': ['edgeitem'], 'is_optional': False}, {'param_name': 'linewidth', 'param_type': ['linewidt'], 'is_optional': False}, {'param_name': 'profile', 'param_type': ['profil'], 'is_optional': False}, {'param_name': 'sci_mode', 'param_type': ['sci_mod'], 'is_optional': False}]",None
Identity,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': False}]",Tensor
Event,"[{'param_name': 'enable_timing', 'param_type': ['bool'], 'is_optional': True}]",None
torch.Tensor.le,[],Tensor
L1Loss,"[{'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.tile,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dims', 'param_type': ['tuple'], 'is_optional': False}]",Tensor
torch._foreach_expm1,[],List
torch.matrix_power,[],Tensor
torch.Tensor.log_,[],Tensor
ConstantPad2d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.nn.utils.prune.identity,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': False}]",modulennModule
torch.Tensor.sparse_resize_and_clear_,"[{'param_name': 'size', 'param_type': ['t'], 'is_optional': False}, {'param_name': 'sparse_dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dense_dim', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.initial_seed,[],int
torch.mv,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'vec', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.transpose,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim0', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dim1', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.heaviside,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'values', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.select_scatter,[],Tensor
DTypeConfig,[],DTypeConfig
Parameter,"[{'param_name': 'Parameter', 'param_type': ['Paramete'], 'is_optional': False}]",None
torch.autograd.Function.jvp,[],Any
torch.Tensor.polygamma_,[],Tensor
torch.Tensor.erfinv_,[],Tensor
torch.linalg.eigvals,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.vander,"[{'param_name': 'x', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'N', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'increasing', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.negative_,[],Tensor
AvgPool2d,"[{'param_name': 'kernel_size', 'param_type': ['Union', 'Tuple', 'int]]'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['Union', 'Tuple', 'int]]'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['Union', 'Tuple', 'int]]'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'count_include_pad', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'divisor_override', 'param_type': ['Optional'], 'is_optional': False}]",None
torch.Tensor.bitwise_not,[],Tensor
torch.Tensor.asin,[],Tensor
torch.fft.hfftn,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardnon'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.tril,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'diagonal', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.isfinite,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
prepare_qat_fx,"[{'param_name': 'model', 'param_type': [''], 'is_optional': False}, {'param_name': 'qconfig_mapping', 'param_type': [''], 'is_optional': False}, {'param_name': 'example_inputs', 'param_type': [''], 'is_optional': False}, {'param_name': 'prepare_custom_config', 'param_type': [''], 'is_optional': False}, {'param_name': 'backend_config', 'param_type': [''], 'is_optional': False}]",GraphModule
ParameterDict,"[{'param_name': '', 'param_type': [''], 'is_optional': False}]",ParameterDict
torch.Tensor.atan2_,[],Tensor
torch.cuda.memory_cached,[],int
torch.round,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'decimals', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",NoteThisfunctionimplementstheroundhalftoeventobreaktieswhenanumberisequidistantfromtwointegerseground25is2WhentheattrdecimalsargumentisspecifiedthealgorithmusedissimilartoNumPysaroundThisalgorithmisfastbutinexactanditcaneasilyoverflowforlowprecisiondtypesEgroundtensor
torch.sort,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'descending', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'stable', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.index_fill,[],Tensor
torch.arctan,[],Tensor
torch.Tensor.int,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
AdaptiveAvgPool1d,"[{'param_name': 'output_size', 'param_type': ['Union', 'Tuple'], 'is_optional': False}]",None
torch.Tensor.dim_order,"[{'param_name': 'None', 'param_type': ['None'], 'is_optional': False}]",tuple
torch.Tensor.prod,[],Tensor
torch._foreach_trunc,[],List
torch.logical_xor,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.cfloat,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.multiply,[],Tensor
torch.Tensor.tensor_split,[],Tensor
torch.Tensor.logical_not,[],Tensor
torch.Tensor.negative,[],Tensor
torch.argmin,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.Tensor.orgqr,[],Tensor
torch.ones_like,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
Linear,"[{'param_name': 'mod', 'param_type': ['Module'], 'is_optional': False}]",None
LambdaLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'lr_lambda', 'param_type': ['function', 'list'], 'is_optional': False}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.sparse_resize_,"[{'param_name': 'size', 'param_type': ['t'], 'is_optional': False}, {'param_name': 'sparse_dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dense_dim', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.dsplit,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'indices_or_sections', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.nn.functional.batch_norm,[],Tensor
torch.Tensor.lt_,[],Tensor
torch.Tensor.resolve_neg,[],Tensor
torch.histc,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'bins', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'min', 'param_type': ['Scalar'], 'is_optional': False}, {'param_name': 'max', 'param_type': ['Scalar'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.cuda.comm.gather,"[{'param_name': 'tensors', 'param_type': ['Iterable'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'destination', 'param_type': ['t', 'str', 'int'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor', 'keyw'], 'is_optional': True}]",None
torch.logdet,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.split,"[{'param_name': 'tensor', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'split_size_or_sections', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",Tuple
torch.Tensor.log1p_,[],Tensor
torch.erfc,[],Tensor
torch.nn.utils.clip_grad_value_,"[{'param_name': 'clip_value', 'param_type': ['clip_valu'], 'is_optional': False}]",None
torch.norm,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'p', 'param_type': ['int', 'float', 'inf', 'inf', 'fro', 'nuc'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int', 'tupleofints', 'listofints'], 'is_optional': True}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",None
torch._foreach_exp,[],List
torch.Tensor.bitwise_or,[],Tensor
torch.cummin,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.jit.script_if_tracing,"[{'param_name': 'fn', 'param_type': ['f'], 'is_optional': False}]",None
LazyConvTranspose1d,"[{'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'output_padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}]",None
torch.Tensor.ldexp_,[],Tensor
torch.nn.functional.fractional_max_pool2d,"[{'param_name': 'kernel_size', 'param_type': ['kernel_siz'], 'is_optional': False}, {'param_name': 'output_size', 'param_type': ['output_siz'], 'is_optional': False}, {'param_name': 'output_ratio', 'param_type': ['output_rati'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['return_indice'], 'is_optional': False}]",None
torch.get_float32_matmul_precision,[],str
torch.compiler.allow_in_graph,"[{'param_name': 'fn', 'param_type': ['f'], 'is_optional': False}]",None
torch.Tensor.logical_xor,[],Tensor
StreamContext,"[{'param_name': 'Stream', 'param_type': ['Stream'], 'is_optional': False}]",None
torch.igamma,[],Tensor
torch.nn.functional.threshold_,[],Tensor
MaxPool3d,"[{'param_name': 'kernel_size', 'param_type': ['Union', 'Tuple', 'int', 'int]]'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['Union', 'Tuple', 'int', 'int]]'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['Union', 'Tuple', 'int', 'int]]'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['Union', 'Tuple', 'int', 'int]]'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['bool'], 'is_optional': False}]",None
torch.save,"[{'param_name': 'obj', 'param_type': ['object'], 'is_optional': False}, {'param_name': 'f', 'param_type': ['Union', 'PathLike', 'BinaryIO', 'IO'], 'is_optional': False}, {'param_name': 'pickle_module', 'param_type': ['Any'], 'is_optional': False}, {'param_name': 'pickle_protocol', 'param_type': ['int'], 'is_optional': False}]",None
torch.signal.windows.cosine,"[{'param_name': 'M', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'sym', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
hardtanh,[],Tensor
torch.Tensor.gt_,[],Tensor
torch.Tensor.any,[],Tensor
torch.block_diag,"[{'param_name': 'tensors', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.sin,[],Tensor
device,"[{'param_name': 'device', 'param_type': ['t', 'int'], 'is_optional': False}]",None
torch.nn.utils.remove_spectral_norm,"[{'param_name': 'module', 'param_type': ['Module'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': True}]",T_module
ParametrizationList,"[{'param_name': 'modules', 'param_type': ['sequence'], 'is_optional': False}, {'param_name': 'original', 'param_type': ['Parameter', 'Tensor'], 'is_optional': False}, {'param_name': 'unsafe', 'param_type': ['bool'], 'is_optional': False}]",None
torch.broadcast_tensors,"[{'param_name': 'tensors', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.sinh_,[],Tensor
ConstantPad3d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.cuda.set_stream,"[{'param_name': 'stream', 'param_type': ['Stream'], 'is_optional': False}]",None
torch.cuda.comm.broadcast,"[{'param_name': 'tensor', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'devices', 'param_type': ['Iterable', 'str'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Sequence', 'keyw'], 'is_optional': True}]",None
torch.optim.Optimizer.zero_grad,"[{'param_name': 'set_to_none', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.untyped_storage,[],t
torch.movedim,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'source', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'destination', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.lu,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'pivot', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'get_infos', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",Tensor
torch.cpu.device_count,[],int
torch.Tensor.hardshrink,[],Tensor
torch.as_tensor,"[{'param_name': 'data', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.ceil,[],Tensor
torch.aminmax,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Optional', 'Tensor'], 'is_optional': False}]",None
torch.diagonal_scatter,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'src', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'offset', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim1', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim2', 'param_type': ['int'], 'is_optional': True}]",Tensor
torch.Tensor.broadcast_to,[],Tensor
torch.autograd.profiler.load_nvprof,"[{'param_name': 'path', 'param_type': ['str'], 'is_optional': False}]",None
torch.take_along_dim,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'indices', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.unbind,[],seq
BackendConfig,[],BackendConfig
torch.Tensor.values,[],Tensor
torch.Tensor.random_,[],Tensor
torch.histogramdd,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'bins', 'param_type': ['bin'], 'is_optional': False}, {'param_name': 'range', 'param_type': ['sequenceoffloat'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'density', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.signal.windows.kaiser,"[{'param_name': 'M', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'beta', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'sym', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.tensordot,"[{'param_name': 'a', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'b', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dims', 'param_type': ['intorTuple', 'List'], 'is_optional': False}]",None
SobolEngine,"[{'param_name': 'dimension', 'param_type': ['Int'], 'is_optional': False}, {'param_name': 'scramble', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'seed', 'param_type': ['Int'], 'is_optional': True}]",Tensor
torch.nn.utils.parametrize.register_parametrization,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'tensor_name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'parametrization', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'unsafe', 'param_type': ['bool'], 'is_optional': False}]",Module
torch.linalg.inv,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.set_default_tensor_type,"[{'param_name': 't', 'param_type': ['type', 'string'], 'is_optional': False}]",None
torch.logit,[],Tensor
torch.dot,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
InstanceNorm2d,"[{'param_name': 'num_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
torch.range,"[{'param_name': 'start', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'end', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'step', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.matrix_exp,[],Tensor
torch.Tensor.copysign,[],Tensor
torch.nn.functional.relu6,[],Tensor
torch.nn.functional.triplet_margin_loss,[],Tensor
torch.Tensor.logical_or_,[],Tensor
torch.signbit,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.cuda.jiterator._create_multi_output_jit_fn,"[{'param_name': 'code_string', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'num_outputs', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kwargs', 'param_type': ['Dict'], 'is_optional': True}]",Callable
torch.clamp,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'min', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'max', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.functional.adaptive_max_pool3d,"[{'param_name': 'output_size', 'param_type': ['output_siz'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['return_indice'], 'is_optional': False}]",None
torch.set_flush_denormal,"[{'param_name': 'mode', 'param_type': ['bool'], 'is_optional': False}]",bool
torch.get_num_threads,[],int
torch.adjoint,[],Tensor
torch.is_complex,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.atanh,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
ExternalStream,"[{'param_name': 'stream_ptr', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",None
torch.Tensor.cholesky,[],Tensor
torch.cross,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.functional.margin_ranking_loss,[],Tensor
torch.isin,"[{'param_name': 'elements', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'test_elements', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'assume_unique', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'invert', 'param_type': ['bool'], 'is_optional': True}]",Tensor
Hardswish,"[{'param_name': 'scale', 'param_type': ['scal'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['zero_poin'], 'is_optional': False}]",None
torch.cuda.caching_allocator_delete,"[{'param_name': 'mem_ptr', 'param_type': ['int'], 'is_optional': False}]",None
torch._foreach_log1p,[],List
torch.Tensor.fix_,[],Tensor
torch.Tensor.erfinv,[],Tensor
torch.Tensor.bool,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.flipud,[],Tensor
torch.Tensor.floor_divide,[],Tensor
torch.asarray,"[{'param_name': 'obj', 'param_type': ['object'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'copy', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.fft.rfft2,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardnon'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.addmm_,[],Tensor
torch.linalg.matrix_rank,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'tol', 'param_type': ['float', 'Tensor'], 'is_optional': True}, {'param_name': 'atol', 'param_type': ['float', 'Tensor'], 'is_optional': True}, {'param_name': 'rtol', 'param_type': ['float', 'Tensor'], 'is_optional': True}, {'param_name': 'hermitian', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.functional.prelu,[],Tensor
torch.lcm,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.reciprocal,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.as_subclass,[],Tensor
torch.nn.functional.ctc_loss,"[{'param_name': 'log_probs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'targets', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'input_lengths', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'target_lengths', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'blank', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'zero_infinity', 'param_type': ['bool'], 'is_optional': True}]",Tensor
MaxUnpool1d,"[{'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch._foreach_log,[],List
torch.svd_lowrank,[],Tuple
torch.tan,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.linalg.vecdot,"[{'param_name': 'x', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'y', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.randn_like,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.inverse,[],Tensor
torch.nn.functional.nll_loss,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'target', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'ignore_index', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",Tensor
torch.bitwise_xor,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['othe'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.quantize_per_tensor,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'scale', 'param_type': ['float', 'Tensor'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['int', 'Tensor'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': False}]",Tensor
torch.vdot,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.nn.functional.dropout,"[{'param_name': 'p', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'training', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",Tensor
Rprop,"[{'param_name': 'params', 'param_type': ['iterable'], 'is_optional': False}, {'param_name': 'lr', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'etas', 'param_type': ['Tuple', 'float]'], 'is_optional': True}, {'param_name': 'step_sizes', 'param_type': ['Tuple', 'float]'], 'is_optional': True}, {'param_name': 'foreach', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'maximize', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'differentiable', 'param_type': ['bool'], 'is_optional': True}]",t
torch.eye,"[{'param_name': 'n', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'm', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.trace,[],Tensor
torch.autograd.Function.forward,[],Any
torch.nn.functional.celu,[],Tensor
torch.cuda.memory_usage,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",int
torch.topk,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'k', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'largest', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'sorted', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.lerp,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'end', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['float', 'Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",None
torch.fft.ihfft,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'n', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardn'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.chunk,[],Tensor
torch.Tensor.acos_,[],Tensor
leaky_relu,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'negative_slope', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'scale', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['Optional'], 'is_optional': False}]",None
torch.lu_unpack,"[{'param_name': 'LU_data', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'LU_pivots', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'unpack_data', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'unpack_pivots', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.ldexp,[],Tensor
torch.nn.functional.avg_pool1d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['kernel_siz'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['ceil_mod'], 'is_optional': False}, {'param_name': 'count_include_pad', 'param_type': ['count_include_pa'], 'is_optional': False}]",Tensor
torch.nn.utils.rnn.pack_padded_sequence,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'lengths', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'enforce_sorted', 'param_type': ['bool'], 'is_optional': True}]",PackedSequence
torch._foreach_neg,[],List
torch.nanquantile,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'q', 'param_type': ['float', 'Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'interpolation', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.cuda.manual_seed_all,"[{'param_name': 'seed', 'param_type': ['int'], 'is_optional': False}]",None
torch.t,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
PrepareCustomConfig,[],PrepareCustomConfig
AlphaDropout,"[{'param_name': 'p', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': True}]",None
torch.fft.irfftn,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardn'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.trapezoid,"[{'param_name': 'y', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'x', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dx', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.Tensor.half,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.mps.get_rng_state,[],Tensor
torch.set_rng_state,"[{'param_name': 'new_state', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.Tensor.fix,[],Tensor
torch.Tensor.i0,[],Tensor
LPPool1d,"[{'param_name': 'kernel_size', 'param_type': ['Union', 'Tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['Union', 'Tuple'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['bool'], 'is_optional': False}]",None
torch.nn.functional.fold,[],Tensor
torch.nn.modules.module.register_module_full_backward_hook,[],t
torch.repeat_interleave,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'repeats', 'param_type': ['Tensor', 'int'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'output_size', 'param_type': ['int'], 'is_optional': True}]",Tensor
torch.sgn,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.mvlgamma_,[],Tensor
torch.Tensor.reshape_as,"[{'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.sinc,[],Tensor
torch.Tensor.sqrt_,[],Tensor
torch.Tensor.expand,"[{'param_name': 'sizes', 'param_type': ['t', 'int'], 'is_optional': False}]",Tensor
torch.Tensor.dim,[],int
torch.mps.current_allocated_memory,[],int
torch.nn.functional.adaptive_avg_pool1d,"[{'param_name': 'output_size', 'param_type': ['output_siz'], 'is_optional': False}]",Tensor
torch.cuda.default_stream,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",Stream
torch._foreach_floor,[],List
torch.select,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['int'], 'is_optional': False}]",Tensor
ParameterList,"[{'param_name': 'ParameterList', 'param_type': ['ParameterListcanbeusedlikearegularPythonlist', 'Tensor', 'andwillbevisiblebyallModulemethods'], 'is_optional': False}]",ParameterList
torch.Tensor.view_as,"[{'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.nn.functional.upsample,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['intorTuple', 'int]orTuple', 'int', 'int]'], 'is_optional': False}, {'param_name': 'scale_factor', 'param_type': ['float', 'Tuple'], 'is_optional': False}, {'param_name': 'mode', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'align_corners', 'param_type': ['bool'], 'is_optional': True}]",None
GLU,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",None
torch.Tensor.cumprod_,[],Tensor
torch.istft,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'B', 'param_type': ['Bisanoptionalbatchdimensio'], 'is_optional': False}, {'param_name': 'N', 'param_type': ['n_fft2'], 'is_optional': False}, {'param_name': 'T', 'param_type': ['lengthn_fft'], 'is_optional': False}, {'param_name': 'n_fft', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'hop_length', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'win_length', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'window', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'center', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'normalized', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'onesided', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'length', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'return_complex', 'param_type': ['Optional'], 'is_optional': False}]",Tensor
torch.Tensor.amin,[],Tensor
torch.sparse_bsr_tensor,"[{'param_name': 'crow_indices', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'col_indices', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'values', 'param_type': ['array_list'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['list', 'tuple', 't'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_invariants', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.addcmul,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'tensor1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'tensor2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'value', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.heaviside,[],Tensor
torch.Tensor.roll,[],Tensor
torch.Tensor.erf,[],Tensor
torch.linalg.solve_triangular,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'B', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'upper', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'left', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'unitriangular', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.fft.irfft2,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardn'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.masked_select,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mask', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.logaddexp2,[],Tensor
torch._foreach_cos,[],List
torch.sparse_bsc_tensor,"[{'param_name': 'ccol_indices', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'row_indices', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'values', 'param_type': ['array_list'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['list', 'tuple', 't'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_invariants', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch._foreach_sqrt,[],List
torch.sparse_compressed_tensor,"[{'param_name': 'compressed_indices', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'plain_indices', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'values', 'param_type': ['array_list'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['list', 'tuple', 't'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t', 'required'], 'is_optional': False}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_invariants', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.nn.functional.mse_loss,[],Tensor
GraphInfo,"[{'param_name': 'repro_dir', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['Optional'], 'is_optional': False}]",List
torch.frac,[],Tensor
torch.Tensor.dist,[],Tensor
torch.Tensor.smm,[],Tensor
set_grad_enabled,"[{'param_name': 'mode', 'param_type': ['bool'], 'is_optional': False}]",None
torch.triu,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'diagonal', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.contiguous,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.var_mean,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'correction', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",None
torch.view_as_complex,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.scatter_,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'src', 'param_type': ['Tensor', 'float'], 'is_optional': False}, {'param_name': 'reduce', 'param_type': ['str'], 'is_optional': True}]",Tensor
UninitializedBuffer,"[{'param_name': 'The', 'param_type': ['Thedefaultdevice'], 'is_optional': False}]",None
torch.addmv,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'vec', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'beta', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'alpha', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.baddbmm,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'batch1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'batch2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'beta', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'alpha', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.utils.get_cpp_backtrace,[],str
torch.Tensor.logical_and_,[],Tensor
torch.Tensor.logdet,[],Tensor
torch.acosh,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.float,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
AdaptiveAvgPool2d,"[{'param_name': 'output_size', 'param_type': ['Union', 'None', 'Tuple', 'Optional'], 'is_optional': False}]",None
torch.nanmean,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.fake_quantize_per_tensor_affine,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'scale', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'quant_min', 'param_type': ['int64'], 'is_optional': False}, {'param_name': 'quant_max', 'param_type': ['int64'], 'is_optional': False}]",Tensor
torch.nonzero,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.cumsum,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.autograd.functional.vhp,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'inputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'v', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'create_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'strict', 'param_type': ['bool'], 'is_optional': True}]",outputtuple
torch.sparse.log_softmax,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.nn.utils.vector_to_parameters,"[{'param_name': '', 'param_type': [''], 'is_optional': False}]",None
torch.Tensor.is_set_to,[],bool
ReflectionPad1d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.Tensor.le_,[],Tensor
torch.Tensor.bitwise_right_shift,[],Tensor
torch.Tensor.cholesky_inverse,[],Tensor
torch.fft.ifft2,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardn'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.clamp_,[],Tensor
torch.func.jvp,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'primals', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'tangents', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'has_aux', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.data_ptr,[],int
ReplicationPad1d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.Tensor.is_coalesced,[],bool
torch.func.vmap,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'in_dims', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out_dims', 'param_type': ['int', 'Tuple'], 'is_optional': False}, {'param_name': 'randomness', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'chunk_size', 'param_type': ['None', 'int'], 'is_optional': False}]",Callable
torch.nn.functional.tanh,[],Tensor
torch.Tensor.arctanh,[],Tensor
torch.Tensor.zero_,[],Tensor
torch.can_cast,"[{'param_name': 'from', 'param_type': ['dtype'], 'is_optional': False}, {'param_name': 'to', 'param_type': ['dtype'], 'is_optional': False}]",bool
torch.Tensor.frac_,[],Tensor
torch.from_numpy,[],Tensor
torch.nn.utils.prune.is_pruned,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}]",None
torch.Tensor.tolist,[],list
TripletMarginWithDistanceLoss,"[{'param_name': 'distance_function', 'param_type': ['Callable'], 'is_optional': True}, {'param_name': 'margin', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'swap', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.linalg.solve,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'B', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'left', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.slice_scatter,[],Tensor
torch.nn.modules.module.register_module_forward_pre_hook,"[{'param_name': 'This', 'param_type': ['Thishookhasprecedenceoverthespecificmodulehooksregisteredwithregister_f'], 'is_optional': False}]",t
torch.logical_and,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.sum,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.neg,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.polygamma,[],Tensor
torch.cuda.comm.scatter,"[{'param_name': 'tensor', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'devices', 'param_type': ['Iterable', 'str'], 'is_optional': True}, {'param_name': 'chunk_sizes', 'param_type': ['Iterable'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'streams', 'param_type': ['Iterable'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Sequence', 'keyw'], 'is_optional': True}]",None
torch.Tensor.storage_type,[],type
LinearLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'start_factor', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'end_factor', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'total_iters', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.nn.functional.bilinear,[],Tensor
torch.Tensor.floor,[],Tensor
torch.remainder,"[{'param_name': 'input', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
Adadelta,"[{'param_name': 'params', 'param_type': ['iterable'], 'is_optional': False}, {'param_name': 'rho', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'lr', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'weight_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'foreach', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'maximize', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'differentiable', 'param_type': ['bool'], 'is_optional': True}]",t
torch.Tensor.sub_,[],Tensor
torch.isclose,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'atol', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'rtol', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'equal_nan', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.cuda.memory_summary,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'abbreviated', 'param_type': ['bool'], 'is_optional': True}]",str
torch.Tensor.copy_,"[{'param_name': 'src', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'non_blocking', 'param_type': ['bool'], 'is_optional': False}]",Tensor
GELU,"[{'param_name': 'approximate', 'param_type': ['str'], 'is_optional': True}]",None
torch.frombuffer,"[{'param_name': 'buffer', 'param_type': ['object'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': False}, {'param_name': 'count', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'offset', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.less,[],Tensor
torch.Tensor.to_sparse,"[{'param_name': 'sparseDims', 'param_type': ['int'], 'is_optional': True}]",Tensor
torch.Tensor.logical_or,[],Tensor
torch.empty_like,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.sqrt,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.gradient,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'spacing', 'param_type': ['scalar', 'listofscalar', 'Tensor'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int', 'listofint'], 'is_optional': True}, {'param_name': 'edge_order', 'param_type': ['int'], 'is_optional': True}]",Tensor
torch.is_conj,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.nn.functional.logsigmoid,[],Tensor
torch.Tensor.rot90,[],Tensor
torch._foreach_sin,[],List
torch.signal.windows.bartlett,"[{'param_name': 'M', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'sym', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
PixelShuffle,"[{'param_name': 'upscale_factor', 'param_type': ['int'], 'is_optional': False}]",None
torch.atleast_3d,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.func.grad_and_value,"[{'param_name': 'func', 'param_type': ['Callable'], 'is_optional': False}, {'param_name': 'argnums', 'param_type': ['int', 'Tuple'], 'is_optional': False}, {'param_name': 'has_aux', 'param_type': ['bool'], 'is_optional': False}]",Callable
ConstantLR,"[{'param_name': 'optimizer', 'param_type': ['Optimizer'], 'is_optional': False}, {'param_name': 'factor', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'total_iters', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'last_epoch', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'verbose', 'param_type': ['bool'], 'is_optional': False}]",None
torch.log1p,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.lobpcg,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'B', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'X', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'iK', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'k', 'param_type': ['integer'], 'is_optional': True}, {'param_name': 'n', 'param_type': ['integer'], 'is_optional': True}, {'param_name': 'tol', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'largest', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'method', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'niter', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'tracker', 'param_type': ['callable'], 'is_optional': True}, {'param_name': 'ortho_iparams', 'param_type': ['dict'], 'is_optional': True}, {'param_name': 'ortho_fparams', 'param_type': ['dict'], 'is_optional': True}, {'param_name': 'ortho_bparams', 'param_type': ['dict'], 'is_optional': True}]",Tensor
torch.Tensor.to_sparse_bsc,"[{'param_name': 'blocksize', 'param_type': ['list', 'tuple', 't'], 'is_optional': True}, {'param_name': 'dense_dim', 'param_type': ['int'], 'is_optional': True}]",Tensor
torch.logaddexp,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.col_indices,[],Tensor
QConfigMapping,[],QConfigMapping
torch.Tensor.qscheme,[],t
torch.Tensor.coalesce,[],Tensor
torch.cuda.clock_rate,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",int
torch.Tensor.round_,[],Tensor
torch.nn.functional.leaky_relu_,[],Tensor
torch.index_add,[],Tensor
torch.Tensor.numel,[],int
torch.prod,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.cuda.comm.reduce_add,"[{'param_name': 'inputs', 'param_type': ['Iterable'], 'is_optional': False}, {'param_name': 'destination', 'param_type': ['int'], 'is_optional': True}]",None
torch.vsplit,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'indices_or_sections', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.linalg.matrix_exp,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.t_,[],Tensor
torch.are_deterministic_algorithms_enabled,[],bool
torch.Tensor.sinh,[],Tensor
torch.autograd.functional.jvp,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'inputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'v', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'create_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'strict', 'param_type': ['bool'], 'is_optional': True}]",outputtuple
torch.Tensor.asin_,[],Tensor
torch.Tensor.lgamma_,[],Tensor
torch.Tensor.dsplit,[],Tensor
torch.Tensor.select,[],Tensor
torch.nn.functional.soft_margin_loss,[],Tensor
GroupNorm,"[{'param_name': 'num_groups', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'num_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}]",None
adaptive_avg_pool2d,[],Tensor
torch._logging.set_logs,"[{'param_name': 'all', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'dynamo', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'aot', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'inductor', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'dynamic', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'distributed', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'onnx', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'bytecode', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'aot_graphs', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'aot_joint_graph', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'ddp_graphs', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'graph', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'graph_code', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'graph_breaks', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'graph_sizes', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'guards', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'recompiles', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'trace_source', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'trace_call', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'output_code', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'schedule', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'perf_hints', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'onnx_diagnostics', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'modules', 'param_type': ['dict'], 'is_optional': False}]",None
torch.min,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",Tensor
torch.func.jacfwd,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'argnums', 'param_type': ['int', 'Tuple'], 'is_optional': False}, {'param_name': 'has_aux', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'randomness', 'param_type': ['str'], 'is_optional': False}]",None
torch.where,"[{'param_name': 'condition', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'input', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.acos,[],Tensor
torch.nn.functional.max_unpool3d,[],Tensor
torch.nn.utils.rnn.unpack_sequence,"[{'param_name': 'packed_sequences', 'param_type': ['PackedSequence'], 'is_optional': False}]",List
torch.divide,[],Tensor
torch.Tensor.cross,[],Tensor
torch.is_tensor,"[{'param_name': 'obj', 'param_type': ['Object'], 'is_optional': False}]",None
torch.bucketize,"[{'param_name': 'input', 'param_type': ['Tensor', 'Scalar'], 'is_optional': False}, {'param_name': 'boundaries', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out_int32', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'right', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
FractionalMaxPool2d,"[{'param_name': 'kernel_size', 'param_type': ['Union', 'Tuple', 'int]]'], 'is_optional': False}, {'param_name': 'output_size', 'param_type': ['Union', 'Tuple', 'int]]'], 'is_optional': False}, {'param_name': 'output_ratio', 'param_type': ['Union', 'Tuple', 'float]]'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['bool'], 'is_optional': False}]",None
torch.ceil,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.linalg.qr,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.ceil_,[],Tensor
Conv1d,"[{'param_name': 'in_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': True}, {'param_name': 'padding_mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}]",None
torch.column_stack,"[{'param_name': 'tensors', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.isneginf,[],Tensor
torch.Tensor.to_sparse_csc,"[{'param_name': 'dense_dim', 'param_type': ['int'], 'is_optional': True}]",Tensor
LeakyReLU,"[{'param_name': 'negative_slope', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",None
torch.Tensor.absolute,[],Tensor
torch.fix,[],Tensor
torch.Tensor.sparse_mask,"[{'param_name': 'mask', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch._foreach_erf,[],List
torch.func.vjp,"[{'param_name': 'func', 'param_type': ['Callable'], 'is_optional': False}, {'param_name': 'primals', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'has_aux', 'param_type': ['bool'], 'is_optional': False}]",None
torch.var,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'correction', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.select_scatter,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'src', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.cholesky_inverse,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'upper', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.scatter_reduce_,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'src', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'reduce', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'include_self', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.get_num_interop_threads,[],int
torch.nn.functional.elu,[],Tensor
torch.pca_lowrank,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'q', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'center', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'niter', 'param_type': ['int'], 'is_optional': True}]",Tuple
torch.cuda.set_sync_debug_mode,"[{'param_name': 'debug_mode', 'param_type': ['str', 'int'], 'is_optional': False}]",None
torch.func.jacrev,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'argnums', 'param_type': ['int', 'Tuple'], 'is_optional': False}, {'param_name': 'has_aux', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'chunk_size', 'param_type': ['None', 'int'], 'is_optional': False}]",None
torch.fmax,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.isreal,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.cuda.get_allocator_backend,[],str
torch.Tensor.log,[],Tensor
torch.cuda.mem_get_info,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",Tuple
torch.Tensor.div_,[],Tensor
SparseAdam,"[{'param_name': 'A', 'param_type': ['Asimplifiedwayofthinkingabouttheintendedimplementationisassuch'], 'is_optional': False}]",t
Conv3d,"[{'param_name': 'in_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': True}, {'param_name': 'padding_mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}]",None
torch.Tensor.swapdims,[],Tensor
GRU,"[{'param_name': 'input_size', 'param_type': ['input_siz'], 'is_optional': False}, {'param_name': 'hidden_size', 'param_type': ['hidden_siz'], 'is_optional': False}, {'param_name': 'num_layers', 'param_type': ['num_layer'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['batch_firs'], 'is_optional': False}, {'param_name': 'dropout', 'param_type': ['dropou'], 'is_optional': False}, {'param_name': 'bidirectional', 'param_type': ['bidirectiona'], 'is_optional': False}]",None
torch.Tensor.neg_,[],Tensor
torch.ger,[],Tensor
torch.fft.hfft2,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 's', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'norm', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'forward', 'param_type': ['f'], 'is_optional': False}, {'param_name': 'backward', 'param_type': ['backwardnon'], 'is_optional': False}, {'param_name': 'ortho', 'param_type': ['n'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
Dropout3d,"[{'param_name': 'p', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': True}]",None
torch.cuda.get_rng_state,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.stack,"[{'param_name': 'tensors', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
MaxPool1d,"[{'param_name': 'kernel_size', 'param_type': ['Union', 'Tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['Union', 'Tuple'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['Union', 'Tuple'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['Union', 'Tuple'], 'is_optional': False}, {'param_name': 'return_indices', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'ceil_mode', 'param_type': ['bool'], 'is_optional': False}]",None
torch.nn.functional.max_unpool1d,[],Tensor
LogSoftmax,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",None
torch.linalg.norm,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'ord', 'param_type': ['int', 'float', 'inf', 'inf', 'fro', 'nuc'], 'is_optional': True}, {'param_name': 'dim', 'param_type': ['int', 'Tuple'], 'is_optional': True}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.bmm,[],Tensor
torch.floor_divide,"[{'param_name': 'input', 'param_type': ['Tensor', 'Number'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'Number'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.permute,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dims', 'param_type': ['tupleofint'], 'is_optional': False}]",Tensor
torch.Tensor.erfc,[],Tensor
torch.bartlett_window,"[{'param_name': 'window_length', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'periodic', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.scatter_add_,"[{'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'index', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'src', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.cuda.utilization,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",int
torch.Tensor.short,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.cuda.current_device,[],int
torch.Tensor.nan_to_num,[],Tensor
torch.isposinf,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.dstack,"[{'param_name': 'tensors', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.sparse.spdiags,"[{'param_name': 'diagonals', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'offsets', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'shape', 'param_type': ['tupleofints'], 'is_optional': False}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.mps.driver_allocated_memory,[],int
torch.cuda.set_rng_state,"[{'param_name': 'new_state', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",None
torch.cuda.memory_reserved,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",int
torch.bitwise_or,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['othe'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.vstack,"[{'param_name': 'tensors', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.remainder,[],Tensor
torch.jit.freeze,"[{'param_name': 'mod', 'param_type': ['ScriptModule'], 'is_optional': False}, {'param_name': 'preserved_attrs', 'param_type': ['Optional'], 'is_optional': False}, {'param_name': 'optimize_numerics', 'param_type': ['bool'], 'is_optional': False}]",None
ChainedScheduler,"[{'param_name': 'schedulers', 'param_type': ['list'], 'is_optional': False}]",None
torch.mvlgamma,[],Tensor
torch.nn.utils.rnn.unpad_sequence,"[{'param_name': 'padded_sequences', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'lengths', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['bool'], 'is_optional': True}]",List
torch.nan_to_num,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'nan', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'posinf', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'neginf', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.cuda.max_memory_cached,[],int
torch.Tensor.ormqr,[],Tensor
EmbeddingBag,"[{'param_name': 'mod', 'param_type': ['Module'], 'is_optional': False}]",None
torch.greater,[],Tensor
torch.Tensor.logical_not_,[],Tensor
torch.not_equal,[],Tensor
torch.cumulative_trapezoid,"[{'param_name': 'y', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'x', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dx', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",Tensor
adaptive_avg_pool3d,[],Tensor
torch.nn.functional.tanhshrink,[],Tensor
quantize_qat,"[{'param_name': 'model', 'param_type': ['mode'], 'is_optional': False}, {'param_name': 'run_fn', 'param_type': ['run_f'], 'is_optional': False}, {'param_name': 'run_args', 'param_type': ['run_arg'], 'is_optional': False}]",None
torch.Tensor.isreal,[],Tensor
torch.nn.functional.mish,[],Tensor
torch.flip,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dims', 'param_type': ['alist'], 'is_optional': False}]",Tensor
torch.Tensor.squeeze_,[],Tensor
torch.cuda.max_memory_allocated,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",int
torch.resolve_neg,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.linalg.tensorsolve,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'B', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dims', 'param_type': ['Tuple'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.nn.utils.clip_grad_norm_,"[{'param_name': 'max_norm', 'param_type': ['max_n'], 'is_optional': False}]",Tensor
torch.Tensor.digamma,[],Tensor
torch.Tensor.lt,[],Tensor
torch.cuda.get_device_capability,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",tupleint
CUDAPluggableAllocator,"[{'param_name': 'path_to_so_file', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'alloc_fn_name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'free_fn_name', 'param_type': ['str'], 'is_optional': False}]",None
DataParallel,"[{'param_name': 'module', 'param_type': ['Module'], 'is_optional': False}, {'param_name': 'device_ids', 'param_type': ['listofint'], 'is_optional': False}, {'param_name': 'output_device', 'param_type': ['int', 't'], 'is_optional': False}]",None
torch.numel,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",int
prepare_fx,"[{'param_name': 'model', 'param_type': [''], 'is_optional': False}, {'param_name': 'qconfig_mapping', 'param_type': [''], 'is_optional': False}, {'param_name': 'example_inputs', 'param_type': [''], 'is_optional': False}, {'param_name': 'prepare_custom_config', 'param_type': [''], 'is_optional': False}, {'param_name': '_equalization_config', 'param_type': [''], 'is_optional': False}, {'param_name': 'backend_config', 'param_type': [''], 'is_optional': False}]",GraphModule
torch.erf,[],Tensor
RMSprop,"[{'param_name': 'params', 'param_type': ['iterable'], 'is_optional': False}, {'param_name': 'lr', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'alpha', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'centered', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'weight_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'foreach', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'maximize', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'differentiable', 'param_type': ['bool'], 'is_optional': True}]",t
torch.Tensor.float_power_,[],Tensor
torch.nn.functional.smooth_l1_loss,[],Tensor
torch.cuda.get_sync_debug_mode,[],int
torch.dist,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'p', 'param_type': ['float'], 'is_optional': True}]",Tensor
RAdam,"[{'param_name': 'params', 'param_type': ['iterable'], 'is_optional': False}, {'param_name': 'lr', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'betas', 'param_type': ['Tuple', 'float]'], 'is_optional': True}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'weight_decay', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'foreach', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'differentiable', 'param_type': ['bool'], 'is_optional': True}]",t
torch.Tensor.moveaxis,[],Tensor
torch.result_type,"[{'param_name': 'tensor1', 'param_type': ['Tensor', 'Number'], 'is_optional': False}, {'param_name': 'tensor2', 'param_type': ['Tensor', 'Number'], 'is_optional': False}]",dtype
torch.dequantize,"[{'param_name': 'tensor', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.i0,[],Tensor
torch.Tensor.cov,[],Tensor
torch.nn.functional.rrelu_,[],Tensor
ObserverBase,"[{'param_name': 'dtype', 'param_type': ['dtyp'], 'is_optional': False}]",None
LazyBatchNorm1d,"[{'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
torch.nn.functional.l1_loss,[],Tensor
torch.Tensor.bernoulli_,[],Tensor
torch.Tensor.mul,[],Tensor
torch.arccosh,[],Tensor
torch.nn.functional.conv3d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['weigh'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}, {'param_name': 'groups', 'param_type': ['group'], 'is_optional': False}]",Tensor
torch.linalg.eigh,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'UPLO', 'param_type': ['L', 'U'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.expand_as,"[{'param_name': 'other', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.positive,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.linalg.vander,"[{'param_name': 'x', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'N', 'param_type': ['int'], 'is_optional': True}]",Tensor
torch.nn.utils.prune.l1_unstructured,"[{'param_name': 'module', 'param_type': ['nnModule'], 'is_optional': False}, {'param_name': 'name', 'param_type': ['str'], 'is_optional': False}, {'param_name': 'amount', 'param_type': ['int', 'float'], 'is_optional': False}, {'param_name': 'importance_scores', 'param_type': ['Tensor'], 'is_optional': False}]",modulennModule
torch.Tensor.uniform_,[],Tensor
torch.add,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'Number'], 'is_optional': False}, {'param_name': 'alpha', 'param_type': ['Number'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.zeros,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.optim.Optimizer.state_dict,[],Dict
torch.set_default_device,"[{'param_name': 'device', 'param_type': ['device', 'string'], 'is_optional': False}]",None
torch.Tensor.add,[],Tensor
InstanceNorm1d,"[{'param_name': 'num_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}]",None
torch.div,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'Number'], 'is_optional': False}, {'param_name': 'rounding_mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'None', 'param_type': ['theoperat'], 'is_optional': False}, {'param_name': 'trunc', 'param_type': ['truncroundstheresultsofthedivisiontowardszeroEquivalenttoCstyleintegerdivision'], 'is_optional': False}, {'param_name': 'floor', 'param_type': ['theoperat'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
hardsigmoid,[],Tensor
torch.nn.functional.instance_norm,[],Tensor
SyncBatchNorm,"[{'param_name': 'num_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'eps', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'momentum', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'affine', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'track_running_stats', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'process_group', 'param_type': ['Optional'], 'is_optional': False}]",None
torch.is_nonzero,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",None
torch.pinverse,[],Tensor
torch.Tensor.float_power,[],Tensor
torch.nn.functional.upsample_bilinear,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['intorTuple', 'int]'], 'is_optional': False}, {'param_name': 'scale_factor', 'param_type': ['intorTuple', 'int]'], 'is_optional': False}]",None
torch.get_default_dtype,[],t
torch.Tensor.clip_,[],Tensor
torch.arcsinh,[],Tensor
torch.max,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",Tensor
torch.full,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'fill_value', 'param_type': ['Scalar'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.var,[],Tensor
torch.Tensor.dot,[],Tensor
torch.Tensor.inner,[],Tensor
torch.Tensor.frac,[],Tensor
ConvTranspose2d,"[{'param_name': 'in_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'output_padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}]",None
torch.Tensor.mm,[],Tensor
torch.arcsin,[],Tensor
torch.Tensor.resize_,"[{'param_name': 'sizes', 'param_type': ['t', 'int'], 'is_optional': False}, {'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
EmbeddingBag,"[{'param_name': 'num_embeddings', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'embedding_dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'max_norm', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'norm_type', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'scale_grad_by_freq', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'mode', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'sparse', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'include_last_offset', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'padding_idx', 'param_type': ['int'], 'is_optional': True}]",Tensor
MultiheadAttention,"[{'param_name': 'embed_dim', 'param_type': ['embed_di'], 'is_optional': False}, {'param_name': 'num_heads', 'param_type': ['num_head'], 'is_optional': False}, {'param_name': 'dropout', 'param_type': ['dropou'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'add_bias_kv', 'param_type': ['add_bias_k'], 'is_optional': False}, {'param_name': 'add_zero_attn', 'param_type': ['add_zero_att'], 'is_optional': False}, {'param_name': 'kdim', 'param_type': ['kdi'], 'is_optional': False}, {'param_name': 'vdim', 'param_type': ['vdi'], 'is_optional': False}, {'param_name': 'batch_first', 'param_type': ['batch_firs'], 'is_optional': False}]",Tuple
torch.asinh,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.floor_divide_,[],Tensor
torch.Tensor.nansum,[],Tensor
KLDivLoss,"[{'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}, {'param_name': 'log_target', 'param_type': ['bool'], 'is_optional': True}]",None
torch.bincount,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'weights', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'minlength', 'param_type': ['int'], 'is_optional': False}]",Tensor
NLLLoss,"[{'param_name': 'weight', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'size_average', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'ignore_index', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'reduce', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'reduction', 'param_type': ['str'], 'is_optional': True}]",None
torch.unique_consecutive,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'return_inverse', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'return_counts', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}]",Tensor
torch.Tensor.logsumexp,[],Tensor
torch.Tensor.set_,"[{'param_name': 'source', 'param_type': ['Tensor', 'St'], 'is_optional': False}, {'param_name': 'storage_offset', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'size', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'stride', 'param_type': ['tuple'], 'is_optional': True}]",Tensor
torch.asin,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
L1Unstructured,"[{'param_name': 'amount', 'param_type': ['int', 'float'], 'is_optional': False}]",Tensor
torch.Tensor.index_select,[],Tensor
torch.angle,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
PixelUnshuffle,"[{'param_name': 'downscale_factor', 'param_type': ['int'], 'is_optional': False}]",None
torch.nn.functional.rrelu,[],Tensor
torch.Tensor.arcsin,[],Tensor
torch.less_equal,[],Tensor
torch.Tensor.fill_,[],Tensor
torch.sign,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.logspace,"[{'param_name': 'start', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'end', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'steps', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'base', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.cuda.get_device_properties,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': False}]",_CudaDeviceProperties
torch.linalg.inv_ex,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'check_errors', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.flip,[],Tensor
Conv1d,"[{'param_name': 'mod', 'param_type': ['Module'], 'is_optional': False}]",None
torch.Tensor.unsqueeze_,[],Tensor
torch.sspaddmm,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat1', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'mat2', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'beta', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'alpha', 'param_type': ['Number'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
DistributedDataParallel,"[{'param_name': '', 'param_type': [''], 'is_optional': False}, {'param_name': 'divide_by_initial_world_size', 'param_type': ['bool'], 'is_optional': True}]",None
torch.Tensor.rad2deg,[],Tensor
torch.diag,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'diagonal', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.geqrf,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
conv2d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['weigh'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}, {'param_name': 'groups', 'param_type': ['group'], 'is_optional': False}, {'param_name': 'padding_mode', 'param_type': ['padding_mod'], 'is_optional': False}, {'param_name': 'scale', 'param_type': ['scal'], 'is_optional': False}, {'param_name': 'zero_point', 'param_type': ['zero_poin'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['dtyp'], 'is_optional': False}]",None
RReLU,"[{'param_name': 'lower', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'upper', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['bool'], 'is_optional': False}]",None
torch.sparse_csr_tensor,"[{'param_name': 'crow_indices', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'col_indices', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'values', 'param_type': ['array_list'], 'is_optional': False}, {'param_name': 'size', 'param_type': ['list', 'tuple', 't'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'check_invariants', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.autograd.functional.vjp,"[{'param_name': 'func', 'param_type': ['function'], 'is_optional': False}, {'param_name': 'inputs', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'v', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'create_graph', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'strict', 'param_type': ['bool'], 'is_optional': True}]",outputtuple
torch.Tensor.permute,[],Tensor
PReLU,"[{'param_name': '', 'param_type': [''], 'is_optional': False}]",None
LazyLinear,"[{'param_name': 'out_features', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['UninitializedParameter'], 'is_optional': False}]",None
torch.Tensor.fill_diagonal_,"[{'param_name': 'fill_value', 'param_type': ['Scalar'], 'is_optional': False}, {'param_name': 'wrap', 'param_type': ['bool'], 'is_optional': False}]",Tensor
torch.set_float32_matmul_precision,"[{'param_name': 'precision', 'param_type': ['str'], 'is_optional': False}]",None
torch.Tensor.std,[],Tensor
ConvTranspose1d,"[{'param_name': 'in_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out_channels', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'kernel_size', 'param_type': ['int', 'tuple'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'output_padding', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'groups', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'bias', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'dilation', 'param_type': ['int'], 'is_optional': True}]",None
torch.Tensor.new_zeros,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'pin_memory', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.Tensor.multiply_,[],Tensor
torch.Tensor.lerp_,[],Tensor
torch.nn.functional.local_response_norm,[],Tensor
Event,"[{'param_name': 'enable_timing', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'blocking', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'interprocess', 'param_type': ['bool'], 'is_optional': False}]",None
torch.view_as_real,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}]",Tensor
torch.Tensor.count_nonzero,[],Tensor
torch.cuda.set_per_process_memory_fraction,"[{'param_name': 'fraction', 'param_type': ['float'], 'is_optional': False}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",None
torch.Tensor.narrow,[],Tensor
torch.jit.load,"[{'param_name': 'f', 'param_type': [''], 'is_optional': False}, {'param_name': 'map_location', 'param_type': ['string', 't'], 'is_optional': False}, {'param_name': '_extra_files', 'param_type': ['dictionaryoffilenametocontent'], 'is_optional': False}, {'param_name': '_restore_shapes', 'param_type': ['bool'], 'is_optional': False}]",None
torch.cat,"[{'param_name': 'tensors', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.trapz,[],Tensor
torch.Tensor.long,"[{'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.Tensor.erfc_,[],Tensor
torch.Tensor.mvlgamma,[],Tensor
torch.log10,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
quantize_dynamic,"[{'param_name': 'model', 'param_type': ['mode'], 'is_optional': False}, {'param_name': 'qconfig_spec', 'param_type': ['qconfig_spe'], 'is_optional': False}, {'param_name': 'A', 'param_type': ['whenthesubmodulealreadyhasqconfigattribute'], 'is_optional': False}, {'param_name': 'A', 'param_type': ['Asetoftypesand', 'inwhichcasethedtypeargumentisusedtospecifythebitwidt'], 'is_optional': False}, {'param_name': 'inplace', 'param_type': ['inplac'], 'is_optional': False}, {'param_name': 'mapping', 'param_type': ['mappin'], 'is_optional': False}]",None
torch.cuda.current_stream,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",Stream
Generator,"[{'param_name': 'device', 'param_type': ['t'], 'is_optional': True}]",Generat
torch.Tensor.is_inference,[],bool
torch.autograd.Function.backward,[],Any
torch.Tensor.q_per_channel_zero_points,[],Tensor
torch.Tensor.fliplr,[],Tensor
torch.Tensor.new_tensor,"[{'param_name': 'data', 'param_type': ['array_like'], 'is_optional': False}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'pin_memory', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.empty,"[{'param_name': 'size', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'pin_memory', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'memory_format', 'param_type': ['t'], 'is_optional': True}]",Tensor
torch.nn.functional.gelu,[],Tensor
torch.nn.functional.conv_transpose2d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['weigh'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'output_padding', 'param_type': ['output_paddin'], 'is_optional': False}, {'param_name': 'groups', 'param_type': ['group'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}]",Tensor
torch.linalg.eigvalsh,"[{'param_name': 'A', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'UPLO', 'param_type': ['L', 'U'], 'is_optional': True}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.ge,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'other', 'param_type': ['Tensor', 'float'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch._foreach_round,[],List
torch.qr,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'some', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'someTrue', 'param_type': ['Q', 'R'], 'is_optional': False}, {'param_name': 'someFalse', 'param_type': ['Q', 'R'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['tuple'], 'is_optional': True}]",None
torch.Tensor.msort,[],Tensor
torch.Tensor.storage,[],t
torch.igammac,[],Tensor
torch.all,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'keepdim', 'param_type': ['bool'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
Conv3d,"[{'param_name': 'mod', 'param_type': ['Module'], 'is_optional': False}]",None
torch.nn.functional.group_norm,[],Tensor
torch.cuda.initial_seed,[],int
Embedding,"[{'param_name': 'mod', 'param_type': ['Module'], 'is_optional': False}]",None
torch.signal.windows.hamming,"[{'param_name': 'M', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'sym', 'param_type': ['bool'], 'is_optional': True}, {'param_name': 'alpha', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'beta', 'param_type': ['float'], 'is_optional': True}, {'param_name': 'dtype', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'layout', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'device', 'param_type': ['t'], 'is_optional': True}, {'param_name': 'requires_grad', 'param_type': ['bool'], 'is_optional': True}]",Tensor
torch.nn.functional.conv1d,"[{'param_name': 'input', 'param_type': ['inpu'], 'is_optional': False}, {'param_name': 'weight', 'param_type': ['weigh'], 'is_optional': False}, {'param_name': 'bias', 'param_type': ['bia'], 'is_optional': False}, {'param_name': 'stride', 'param_type': ['strid'], 'is_optional': False}, {'param_name': 'padding', 'param_type': ['paddin'], 'is_optional': False}, {'param_name': 'dilation', 'param_type': ['dilatio'], 'is_optional': False}, {'param_name': 'groups', 'param_type': ['group'], 'is_optional': False}]",Tensor
torch.Tensor.fmax,[],Tensor
torch.narrow_copy,"[{'param_name': 'input', 'param_type': ['Tensor'], 'is_optional': False}, {'param_name': 'dim', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'start', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'length', 'param_type': ['int'], 'is_optional': False}, {'param_name': 'out', 'param_type': ['Tensor'], 'is_optional': True}]",Tensor
torch.Tensor.addbmm,[],Tensor
torch.swapaxes,[],Tensor
torch.Tensor.clip,[],Tensor
ReplicationPad2d,"[{'param_name': 'padding', 'param_type': ['int', 'tuple'], 'is_optional': False}]",None
torch.cpu.is_available,[],bool
